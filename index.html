<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Turkey Redistricter</title>

  <!-- Leaflet (CDN) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>

  <style>
    :root{
      --bg:#f4f6fb;
      --panel:#ffffff;
      --ink:#0b1220;
      --muted:#516079;
      --border:#d9e1ef;
      --shadow:0 14px 40px rgba(16,24,40,.12);
      --shadow2:0 8px 24px rgba(16,24,40,.10);
      --radius:18px;

      --control:#ffffff;
      --controlBorder:#d7deea;

      --line:#96a3b8;
      --line2:#6b7a92;

      --focus:#111827;
      --focusGlow:0 0 0 4px rgba(17,24,39,.10);
    }

    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1100px 700px at 20% -10%, #ffffff 0%, var(--bg) 55%, var(--bg) 100%);
      color:var(--ink);
      overflow:hidden;
    }

    /* Layout */
    .app{
      height:100%;
      display:grid;
      grid-template-rows: 64px 1fr;
      gap:14px;
      padding:14px;
      box-sizing:border-box;
    }

    .topbar{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow2);
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px 12px;
      gap:12px;
    }

    .brand{
      display:flex;
      align-items:center;
      gap:12px;
      min-width: 260px;
    }
    .dot{
      width:11px;height:11px;border-radius:999px;
      background: conic-gradient(from 190deg, #16a34a, #ef4444, #3b82f6, #16a34a);
      box-shadow:0 0 0 5px rgba(22,163,74,.09);
    }
    .brand h1{
      font-size:16px;
      margin:0;
      letter-spacing:.2px;
    }
    .brand .sub{
      margin:0;
      font-size:12px;
      color:var(--muted);
      margin-top:2px;
    }
    .brandText{ display:flex; flex-direction:column; line-height:1.05; }

    .controls{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    .pill{
      display:flex;
      align-items:center;
      gap:8px;
      background:var(--control);
      border:1px solid var(--controlBorder);
      border-radius: 999px;
      padding:6px 10px;
      box-shadow: 0 6px 14px rgba(16,24,40,.06);
    }

    label{
      font-size:12px;
      color:var(--muted);
      user-select:none;
    }

    select, button{
      font: inherit;
      outline:none;
      border:none;
      background:transparent;
    }

    select{
      font-size:13px;
      color:var(--ink);
      padding:2px 2px;
      cursor:pointer;
      max-width: 260px;
    }

    .btn{
      background: #0b1220;
      color:#fff;
      border-radius: 999px;
      padding:8px 12px;
      font-size:13px;
      cursor:pointer;
      box-shadow: 0 14px 28px rgba(11,18,32,.18);
      border:1px solid rgba(11,18,32,.12);
      transition: transform .06s ease, box-shadow .12s ease;
    }
    .btn:hover{ transform: translateY(-1px); box-shadow: 0 18px 36px rgba(11,18,32,.20); }
    .btn:active{ transform: translateY(0px); }

    .hint{
      font-size:12px;
      color:var(--muted);
      padding-right:6px;
      user-select:none;
    }

    .main{
      display:grid;
      grid-template-columns: 1fr 380px;
      gap:14px;
      min-height:0;
    }

    #mapWrap{
      background: var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
      min-height:0;
    }

    #map{ height:100%; width:100%; }

    /* Right panel */
    .side{
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:0;
    }

    .card{
      background: var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow2);
      padding:12px 12px;
    }
    .card h2{
      margin:0 0 8px 0;
      font-size:13px;
      letter-spacing:.2px;
    }
    .card .small{
      font-size:12px;
      color:var(--muted);
      margin:0;
    }

    .legendRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-top:8px;
    }
    .legendBar{
      height:10px;
      border-radius: 999px;
      border:1px solid rgba(16,24,40,.12);
      flex:1;
      overflow:hidden;
      background:#eef2f7;
    }
    .legendLabels{
      display:flex;
      justify-content:space-between;
      font-size:11px;
      color:var(--muted);
      margin-top:8px;
    }

    .swatches{
      margin-top:10px;
      display:flex;
      flex-direction:column;
      gap:6px;
      max-height:160px;
      overflow:auto;
      padding-right:4px;
    }
    .swatch{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-size:12px;
      color:var(--ink);
    }
    .swatchLeft{
      display:flex; align-items:center; gap:8px; min-width:0;
    }
    .chip{
      width:12px; height:12px; border-radius:4px;
      border:1px solid rgba(0,0,0,.10);
      box-shadow: 0 2px 6px rgba(0,0,0,.08);
      flex:0 0 auto;
    }
    .swatchName{
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width:240px;
    }

    .districtTitle{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .districtTitle h3{
      margin:0;
      font-size:16px;
      letter-spacing:.2px;
      line-height:1.15;
    }
    .badge{
      font-size:11px;
      color:#0b1220;
      background:#eef2f7;
      border:1px solid rgba(11,18,32,.10);
      padding:4px 8px;
      border-radius:999px;
      white-space:nowrap;
    }

    .kv{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px 12px;
      margin-top:8px;
    }
    .k{
      font-size:11px;
      color:var(--muted);
      margin:0 0 2px 0;
    }
    .v{
      font-size:13px;
      margin:0;
      color:var(--ink);
      font-variant-numeric: tabular-nums;
    }

    .divider{
      height:1px;
      background: linear-gradient(90deg, transparent, rgba(81,96,121,.25), transparent);
      margin:10px 0;
    }

    .bars{
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-top:8px;
    }
    .barRow{
      display:grid;
      grid-template-columns: 120px 1fr 70px;
      gap:8px;
      align-items:center;
      font-size:12px;
    }
    .barName{ color:var(--ink); overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .bar{
      height:10px;
      border-radius: 999px;
      background:#eef2f7;
      border:1px solid rgba(16,24,40,.10);
      overflow:hidden;
      position:relative;
    }
    .barFill{
      height:100%;
      border-radius:999px;
      width:0%;
    }
    .barVal{
      font-variant-numeric: tabular-nums;
      text-align:right;
      color:var(--muted);
    }

    /* Leaflet tweaks */
    .leaflet-container{
      background:#dde7f4;
      outline:none;
    }
    .leaflet-control-zoom a{
      border-radius:12px !important;
      box-shadow: 0 10px 24px rgba(16,24,40,.14);
      border:1px solid rgba(16,24,40,.10) !important;
    }
    .leaflet-control-attribution{
      background: rgba(255,255,255,.85) !important;
      border-radius: 10px;
      margin:8px !important;
      border:1px solid rgba(16,24,40,.10);
    }

    /* Floating tooltip (hover) */
    .tip{
      position:absolute;
      pointer-events:none;
      transform: translate(12px, 12px);
      background: rgba(255,255,255,.92);
      border:1px solid rgba(16,24,40,.14);
      border-radius: 12px;
      padding:8px 10px;
      box-shadow: 0 16px 40px rgba(16,24,40,.18);
      font-size:12px;
      color:var(--ink);
      opacity:0;
      transition: opacity .10s ease;
      max-width: 320px;
      backdrop-filter: blur(8px);
    }
    .tip b{ font-size:12px; }
    .tip .tmuted{ color:var(--muted); font-size:11px; }

    @media (max-width: 980px){
      body{ overflow:auto; }
      .app{ height:auto; }
      .main{ grid-template-columns: 1fr; }
      .side{ order:2; }
      #mapWrap{ height: 65vh; }
    }
  </style>
</head>

<body>
  <div class="app">
    <div class="topbar">
      <div class="brand">
        <div class="dot"></div>
        <div class="brandText">
          <h1>Turkey Redistricter</h1>
          <p class="sub">all districts • elections • population • turnout • age</p>
        </div>
      </div>

      <div class="controls">
        <div class="pill">
          <label for="layerSel">Layer</label>
          <select id="layerSel"></select>
        </div>

        <div class="pill" title="Used for Population / Population Change. Age & Turnout use 2024 population + 2024 registered voters.">
          <label for="yearSel">Year</label>
          <select id="yearSel">
            <option value="2014">2014</option>
            <option value="2019">2019</option>
            <option value="2024" selected>2024</option>
          </select>
        </div>

        <button class="btn" id="fitBtn">Fit</button>
        <span class="hint" id="tinyNote"></span>
      </div>
    </div>

    <div class="main">
      <div id="mapWrap">
        <div id="map"></div>
        <div id="tip" class="tip"></div>
      </div>

      <div class="side">
        <div class="card" id="legendCard">
          <h2>Legend</h2>
          <p class="small" id="legendTitle">—</p>
          <div class="legendRow">
            <div class="legendBar" id="legendBar"></div>
          </div>
          <div class="legendLabels" id="legendLabels">
            <span>—</span><span>—</span>
          </div>
          <div class="swatches" id="partySwatches" style="display:none;"></div>
        </div>

        <div class="card" id="districtCard">
          <div class="districtTitle">
            <div>
              <h3 id="dName">Hover or click a district</h3>
              <p class="small" id="dSub">Selection will pin details.</p>
            </div>
            <span class="badge" id="dBadge">—</span>
          </div>

          <div class="kv" id="kvGrid">
            <div><p class="k">Population (year)</p><p class="v" id="popYear">—</p></div>
            <div><p class="k">Population 2024</p><p class="v" id="pop2024">—</p></div>
            <div><p class="k">Pop change</p><p class="v" id="popChg">—</p></div>
            <div><p class="k">Pop change %</p><p class="v" id="popChgPct">—</p></div>
          </div>

          <div class="divider"></div>

          <div class="kv">
            <div><p class="k">Registered (18+)</p><p class="v" id="reg18">—</p></div>
            <div><p class="k">Votes cast</p><p class="v" id="cast">—</p></div>
            <div><p class="k">Turnout</p><p class="v" id="turnout">—</p></div>
            <div><p class="k">Valid votes</p><p class="v" id="valid">—</p></div>
          </div>

          <div class="divider"></div>

          <div class="kv">
            <div><p class="k">0–18 total (est.)</p><p class="v" id="u18Total">—</p></div>
            <div><p class="k">0–18 %</p><p class="v" id="u18Pct">—</p></div>
            <div><p class="k">18+ total</p><p class="v" id="a18Total">—</p></div>
            <div><p class="k">18+ %</p><p class="v" id="a18Pct">—</p></div>
          </div>

          <div class="divider"></div>

          <h2 style="margin:0 0 6px 0; font-size:13px;">Election (winner)</h2>
          <p class="small" id="winLine">—</p>

          <div class="bars" id="topBars"></div>
        </div>
      </div>
    </div>
  </div>

<script>
/* =========================
   Files (same folder)
========================= */
const FILE_GEOJSON = "turkey-admin-level-6.geojson";
const FILE_POPCSV  = "province_district_2014_2019_2024.csv";

/* =========================
   Province plate mapping
========================= */
const PLATE_TO_PROVINCE = [
  null,
  "Adana","Adıyaman","Afyonkarahisar","Ağrı","Amasya","Ankara","Antalya","Artvin","Aydın","Balıkesir",
  "Bilecik","Bingöl","Bitlis","Bolu","Burdur","Bursa","Çanakkale","Çankırı","Çorum","Denizli",
  "Diyarbakır","Edirne","Elazığ","Erzincan","Erzurum","Eskişehir","Gaziantep","Giresun","Gümüşhane","Hakkari",
  "Hatay","Isparta","Mersin","İstanbul","İzmir","Kars","Kastamonu","Kayseri","Kırklareli","Kırşehir",
  "Kocaeli","Konya","Kütahya","Malatya","Manisa","Kahramanmaraş","Mardin","Muğla","Muş","Nevşehir",
  "Niğde","Ordu","Rize","Sakarya","Samsun","Siirt","Sinop","Sivas","Tekirdağ","Tokat",
  "Trabzon","Tunceli","Şanlıurfa","Uşak","Van","Yozgat","Zonguldak","Aksaray","Bayburt","Karaman",
  "Kırıkkale","Batman","Şırnak","Bartın","Ardahan","Iğdır","Yalova","Karabük","Kilis","Osmaniye","Düzce"
];

const provinceToPlate = new Map();
for (let p=1; p<PLATE_TO_PROVINCE.length; p++){
  provinceToPlate.set(keyify(PLATE_TO_PROVINCE[p]), p);
}

/* =========================
   UI Layers
========================= */
const LAYERS = [
  { id:"pop", name:"Population (selected year)", kind:"sequential", legend:"Population" },
  { id:"popchg", name:"Population change (count)", kind:"diverging", legend:"Population change" },
  { id:"popchgpct", name:"Population change (%)", kind:"diverging", legend:"Population change (%)" },
  { id:"e_win", name:"Election: winner (margin shading)", kind:"categorical", legend:"Election winner" },
  { id:"turnout", name:"Turnout (%)", kind:"sequential", legend:"Turnout" },
  { id:"u18pct", name:"Age: 0–18 (% of total)", kind:"sequential", legend:"0–18 share" },
  { id:"u18tot", name:"Age: 0–18 (total)", kind:"sequential", legend:"0–18 total" },
  { id:"a18pct", name:"Age: 18+ (% of total)", kind:"sequential", legend:"18+ share" },
  { id:"a18tot", name:"Age: 18+ (total)", kind:"sequential", legend:"18+ total" },
];

const state = {
  layer: "pop",
  year: 2024,
  geojson: null,
  features: [],
  popIndex: new Map(),      // key (plate|DISTKEY) => {2014,2019,2024}
  electIndex: new Map(),    // key (plate|DISTKEY) => election object
  partyUniverse: new Map(), // party -> count occurrences
  scales: {},               // computed domains per layer
  selected: null,           // leaflet layer (selected)
  hovered: null
};

/* =========================
   Helpers: normalization, parsing
========================= */
function resolveUrl(rel){
  return new URL(rel, window.location.href).toString();
}

function asciiFold(s){
  s = (s ?? "").toString().trim();
  // force dotted/dotless i to normalize well
  s = s.replace(/ı/g, "i").replace(/İ/g, "I");
  // strip diacritics
  s = s.normalize("NFKD").replace(/[\u0300-\u036f]/g, "");
  return s;
}

function asciiName(s){
  return asciiFold(s).replace(/[^A-Za-z0-9]+/g, " ").trim().replace(/\s+/g," ");
}

function keyify(s){
  return asciiFold(s)
    .toUpperCase()
    .replace(/[^A-Z0-9]+/g, " ")
    .trim()
    .replace(/\s+/g, " ");
}

function uniqueKey(plate, distKey){
  return `${plate}|${distKey}`;
}

function clamp01(x){ return Math.max(0, Math.min(1, x)); }

function parseTRInt(x){
  if (x == null) return null;
  let s = String(x).trim();
  if (!s) return null;
  // remove spaces
  s = s.replace(/\s+/g,"");
  // thousands separators "." in TR
  s = s.replace(/\./g,"");
  // some sources might use commas
  s = s.replace(/,/g,".");
  // integer
  const n = Number(s);
  return Number.isFinite(n) ? Math.round(n) : null;
}

function fmtInt(n){
  if (n==null || !Number.isFinite(n)) return "—";
  return n.toLocaleString("tr-TR");
}
function fmtPct(x){
  if (x==null || !Number.isFinite(x)) return "—";
  return (x*100).toFixed(1).replace(".", ",") + "%";
}

/* =========================
   Color utilities
========================= */
function hexToRgb(h){
  const m = h.replace("#","").trim();
  const v = m.length===3 ? m.split("").map(c=>c+c).join("") : m;
  const n = parseInt(v,16);
  return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
}
function rgbToHex(r,g,b){
  const to = (x)=>x.toString(16).padStart(2,"0");
  return "#"+to(r)+to(g)+to(b);
}
function mixHex(a,b,t){
  const A=hexToRgb(a), B=hexToRgb(b);
  const r=Math.round(A.r+(B.r-A.r)*t);
  const g=Math.round(A.g+(B.g-A.g)*t);
  const bb=Math.round(A.b+(B.b-A.b)*t);
  return rgbToHex(r,g,bb);
}

/* =========================
   Party colors (punchy)
========================= */
const PARTY_COLORS = new Map(Object.entries({
  "CHP":"#e11d48",
  "AK PARTI":"#f59e0b",
  "AK PARTİ":"#f59e0b",
  "MHP":"#111827",
  "İYİ PARTİ":"#2563eb",
  "IYI PARTI":"#2563eb",
  "YENIDEN REFAH":"#16a34a",
  "YESIL SOL PARTI":"#10b981",
  "YEŞİL SOL PARTİ":"#10b981",
  "TIP":"#7c3aed",
  "ZAFER PARTISI":"#0ea5e9",
  "ZAFER PARTİSİ":"#0ea5e9",
  "BBP":"#b45309",
  "MEMLEKET":"#8b5cf6",
  "SOL PARTI":"#be123c"
}));

function colorForParty(p){
  const k = keyify(p);
  // normalize some common variants
  const k2 = k.replace(/\s+/g," ").trim();
  for (const [name,col] of PARTY_COLORS.entries()){
    if (keyify(name) === k2) return col;
  }
  // fallback deterministic by hash
  let h=0; for (let i=0;i<k2.length;i++) h=(h*31+k2.charCodeAt(i))|0;
  const hue = Math.abs(h)%360;
  return `hsl(${hue} 82% 48%)`;
}

/* =========================
   District name matching (Merkez etc.)
========================= */
function uniq(arr){ return [...new Set(arr.filter(Boolean))]; }

function distKeyAlternatives(distName, provName){
  const d0 = keyify(distName);
  const p0 = keyify(provName);
  const alts = [d0];

  if (d0 && p0 && d0 === p0) alts.push("MERKEZ");

  if (d0 && p0){
    const removed = d0.replace(new RegExp(`\\b${p0}\\b`, "g"), "").replace(/\s+/g," ").trim();
    if (removed) alts.push(removed);
  }

  for (const k of [...alts]){
    alts.push(k.replace(/\b(ILCE|İLÇE)\b/g,"").replace(/\s+/g," ").trim());
    alts.push(k.replace(/\bMERKEZ\b/g,"").replace(/\s+/g," ").trim());
  }

  return uniq(alts.map(x=>x && x.trim()).filter(Boolean));
}

function findElectionRow(plate, distName, provName, electionsMap){
  for (const dk of distKeyAlternatives(distName, provName)){
    const row = electionsMap.get(uniqueKey(plate, dk));
    if (row) return row;
  }
  return null;
}

/* =========================
   Load election JSON (robust filenames)
========================= */
function titleCaseSimple(s){
  s = (s||"").trim();
  if (!s) return s;
  return s[0].toUpperCase() + s.slice(1);
}

async function tryFetchElectionJson(provName, plate){
  const plate2 = String(plate).padStart(2,"0");
  const ascii = asciiName(provName).replace(/\s+/g,"");

  // prioritize GitHub-style "Istanbul.json" etc.
  const candidates = [
    `${titleCaseSimple(ascii)}.json`,
    `${ascii}.json`,
    `${provName}.json`,
    `${provName.toLocaleLowerCase("tr-TR")}.json`,
    `${ascii.toLowerCase()}.json`,
    `${plate}.json`,
    `${plate2}.json`
  ];

  const uniqList = [...new Set(candidates.filter(Boolean))];

  for (const rel of uniqList){
    try{
      const url = resolveUrl(rel);
      const resp = await fetch(url, { cache:"no-store" });
      if (!resp.ok) continue;
      return await resp.json();
    }catch(_){}
  }
  return null;
}

function parseElectionJson(raw){
  // raw: array of rows (with blank separators + "Oy Orani" rows)
  const out = [];
  if (!Array.isArray(raw)) return out;

  const BASE = new Set([
    "Ilce Id","Ilce Adi","Belde Adi",
    "Kayitli Secmen Sayisi","Oy Kullanan Secmen Sayisi","Gecerli Oy Toplami"
  ]);

  for (const r of raw){
    const id = String(r?.["Ilce Id"] ?? "").trim();
    if (!/^\d+$/.test(id)) continue;

    const district = String(r["Ilce Adi"] ?? "").trim();
    const reg = parseTRInt(r["Kayitli Secmen Sayisi"]);
    const cast = parseTRInt(r["Oy Kullanan Secmen Sayisi"]);
    const valid = parseTRInt(r["Gecerli Oy Toplami"]);

    const votes = {};
    for (const k of Object.keys(r)){
      if (BASE.has(k)) continue;
      const name = String(k ?? "").trim();
      if (!name) continue;
      const v = parseTRInt(r[k]);
      if (v==null) continue;
      votes[name.replace(/\s+/g," ").trim()] = v;
    }

    // winner/runnerup
    const entries = Object.entries(votes).sort((a,b)=>b[1]-a[1]);
    const w = entries[0] ? { party: entries[0][0], votes: entries[0][1] } : null;
    const ru = entries[1] ? { party: entries[1][0], votes: entries[1][1] } : null;

    const marginVotes = (w && ru) ? (w.votes - ru.votes) : null;
    const marginShare = (marginVotes!=null && valid && valid>0) ? (marginVotes/valid) : null;

    out.push({
      district,
      districtKey: keyify(district),
      districtId: Number(id),
      registered: reg,
      cast,
      valid,
      votes,
      winner: w?.party ?? null,
      winnerVotes: w?.votes ?? null,
      runnerup: ru?.party ?? null,
      runnerupVotes: ru?.votes ?? null,
      marginVotes,
      marginShare,
      top: entries.slice(0,6)
    });
  }
  return out;
}

/* =========================
   Load population CSV
========================= */
function parseCSV(text){
  // minimal robust CSV parser (handles quoted fields)
  const rows = [];
  let i=0, field="", row=[], inQ=false;
  const pushField = ()=>{ row.push(field); field=""; };
  const pushRow = ()=>{ rows.push(row); row=[]; };

  while (i < text.length){
    const c = text[i++];
    if (inQ){
      if (c === '"'){
        if (text[i] === '"'){ field += '"'; i++; }
        else inQ=false;
      } else field += c;
    } else {
      if (c === '"') inQ=true;
      else if (c === ',') pushField();
      else if (c === '\n'){
        pushField(); pushRow();
      } else if (c === '\r') {
        // ignore
      } else field += c;
    }
  }
  // last
  if (field.length || row.length){ pushField(); pushRow(); }
  return rows;
}

function buildPopIndex(csvText){
  const rows = parseCSV(csvText);
  if (!rows.length) return;

  const header = rows[0].map(h=>h.trim());
  const idxProv = header.indexOf("Province");
  const idxDist = header.indexOf("District");
  const idx2014 = header.indexOf("2014");
  const idx2019 = header.indexOf("2019");
  const idx2024 = header.indexOf("2024");

  for (let r=1; r<rows.length; r++){
    const row = rows[r];
    const prov = (row[idxProv] ?? "").trim();
    const dist = (row[idxDist] ?? "").trim();
    if (!prov || !dist) continue;

    const plate = provinceToPlate.get(keyify(prov));
    if (!plate) continue;

    const dk = keyify(dist);

    const p2014 = Number(row[idx2014]);
    const p2019 = Number(row[idx2019]);
    const p2024 = Number(row[idx2024]);

    state.popIndex.set(uniqueKey(plate, dk), {
      y2014: Number.isFinite(p2014) ? p2014 : null,
      y2019: Number.isFinite(p2019) ? p2019 : null,
      y2024: Number.isFinite(p2024) ? p2024 : null
    });
  }
}

/* =========================
   Compute per-feature joined metrics
========================= */
function attachDerived(f){
  const p = f.properties;

  // population
  const pop = state.popIndex.get(uniqueKey(p.__plate, p.__districtKey)) || null;
  p.__pop2014 = pop?.y2014 ?? null;
  p.__pop2019 = pop?.y2019 ?? null;
  p.__pop2024 = pop?.y2024 ?? null;

  // election
  let e = state.electIndex.get(uniqueKey(p.__plate, p.__districtKey)) || null;
  if (!e) e = findElectionRow(p.__plate, p.__distName, p.__provName, state.electIndex);
  p.__e = e;

  const pop2024 = p.__pop2024;
  const reg = e?.registered ?? null;
  const cast = e?.cast ?? null;
  const valid = e?.valid ?? null;

  p.__turnout = (reg && cast && reg>0) ? (cast/reg) : null;

  // age: per your spec: use 2024 population and registered voters as 18+
  if (pop2024 != null && reg != null && pop2024 > 0){
    const u18 = Math.max(0, pop2024 - reg);
    p.__u18Tot = u18;
    p.__u18Pct = u18 / pop2024;

    p.__a18Tot = reg;
    p.__a18Pct = reg / pop2024;
  } else {
    p.__u18Tot = p.__u18Pct = p.__a18Tot = p.__a18Pct = null;
  }

  p.__valid = valid;
}

/* =========================
   Scales for legends/colors
========================= */
function computeScales(){
  const feats = state.features;

  function vals(fn){
    const a = [];
    for (const f of feats){
      const v = fn(f.properties);
      if (v!=null && Number.isFinite(v)) a.push(v);
    }
    return a;
  }

  // population (by year)
  state.scales.pop = {
    y2014: extent(vals(p=>p.__pop2014)),
    y2019: extent(vals(p=>p.__pop2019)),
    y2024: extent(vals(p=>p.__pop2024))
  };

  // change depends on selected year (computed on the fly, but we precompute maxAbs)
  state.scales.popchg = {
    prev2019: maxAbs(vals(p=>{
      if (p.__pop2019==null || p.__pop2014==null) return null;
      return p.__pop2019 - p.__pop2014;
    })),
    prev2024: maxAbs(vals(p=>{
      if (p.__pop2024==null || p.__pop2019==null) return null;
      return p.__pop2024 - p.__pop2019;
    }))
  };

  state.scales.popchgpct = {
    prev2019: maxAbs(vals(p=>{
      if (p.__pop2019==null || p.__pop2014==null || p.__pop2014===0) return null;
      return (p.__pop2019 - p.__pop2014)/p.__pop2014;
    })),
    prev2024: maxAbs(vals(p=>{
      if (p.__pop2024==null || p.__pop2019==null || p.__pop2019===0) return null;
      return (p.__pop2024 - p.__pop2019)/p.__pop2019;
    }))
  };

  // turnout
  state.scales.turnout = extent(vals(p=>p.__turnout));

  // age maps
  state.scales.u18pct = extent(vals(p=>p.__u18Pct));
  state.scales.u18tot = extent(vals(p=>p.__u18Tot));
  state.scales.a18pct = extent(vals(p=>p.__a18Pct));
  state.scales.a18tot = extent(vals(p=>p.__a18Tot));
}

function extent(arr){
  if (!arr.length) return [0,1];
  let mn=Infinity, mx=-Infinity;
  for (const v of arr){ if (v<mn) mn=v; if (v>mx) mx=v; }
  if (mn===mx){ mx = mn+1; }
  return [mn,mx];
}
function maxAbs(arr){
  let m=0;
  for (const v of arr){ m = Math.max(m, Math.abs(v)); }
  if (m===0) m=1;
  return m;
}

/* =========================
   Color ramps (light mode)
========================= */
const GREEN_L = "#e8f5e9";
const GREEN_D = "#1b5e20";

const RED_L   = "#fee2e2";
const RED_D   = "#dc2626";

const TURN_L  = "#e0f2fe";
const TURN_D  = "#0369a1";

const U18_L   = "#f3e8ff";
const U18_D   = "#6d28d9";

const A18_L   = "#ecfeff";
const A18_D   = "#0f766e";

function seqColor(t, a, b){
  t = clamp01(Math.pow(t, 0.85));
  return mixHex(a,b,t);
}

function divergeColor(v, maxAbsVal){
  if (v==null || !Number.isFinite(v)) return "#eef2f7";
  const m = Math.max(1e-12, maxAbsVal);
  const t = clamp01(Math.abs(v)/m);
  if (v < 0) return mixHex("#ffffff", RED_D, Math.pow(t, 0.70));
  if (v > 0) return mixHex("#ffffff", GREEN_D, Math.pow(t, 0.70));
  return "#ffffff";
}

/* Election: margin smaller -> lighter */
function electionColor(e){
  if (!e || !e.winner) return "#eef2f7";
  const base = colorForParty(e.winner);
  const ms = (e.marginShare!=null && Number.isFinite(e.marginShare)) ? Math.max(0, Math.min(0.30, e.marginShare)) : 0;
  let t = clamp01(ms / 0.18);
  t = Math.pow(t, 0.55);

  // keep low-margin still clearly colored
  const low  = mixHex("#ffffff", base, 0.62);
  const high = mixHex("#000000", base, 0.12);
  return mixHex(low, high, t);
}

/* =========================
   Map init
========================= */
const map = L.map("map", { preferCanvas:true, zoomControl:false });
L.control.zoom({ position:"topleft" }).addTo(map);

L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  maxZoom: 18,
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

let geoLayer = null;

function baseStyle(feature){
  const p = feature.properties;
  const fill = colorForFeature(p);

  return {
    weight: 0.8,
    opacity: 1,
    color: "rgba(107,122,146,0.75)",
    fillOpacity: 0.92,
    fillColor: fill
  };
}

function hoverStyle(layer){
  layer.setStyle({
    weight: 2.0,
    color: "#111827",
    opacity: 1
  });
  try{ layer.bringToFront(); }catch(_){}
}

function unhoverStyle(layer){
  if (!layer) return;
  if (state.selected === layer) return; // selected keeps its style
  layer.setStyle(baseStyle(layer.feature));
}

function selectStyle(layer){
  layer.setStyle({
    weight: 2.6,
    color: "#111827",
    opacity: 1,
    fillOpacity: 0.95
  });
  try{ layer.bringToFront(); }catch(_){}
}

function clearSelection(){
  if (state.selected){
    state.selected.setStyle(baseStyle(state.selected.feature));
    state.selected = null;
  }
  renderDistrict(null, false);
}

function onEachFeature(feature, layer){
  layer.on("mouseover", (ev)=>{
    state.hovered = layer;
    hoverStyle(layer);
    renderDistrict(layer.feature, state.selected === layer);
    tipShow(ev.originalEvent, layer.feature);
  });
  layer.on("mousemove", (ev)=>{
    tipMove(ev.originalEvent);
  });
  layer.on("mouseout", ()=>{
    tipHide();
    unhoverStyle(layer);
    state.hovered = null;
    if (!state.selected) renderDistrict(null,false);
    else renderDistrict(state.selected.feature, true);
  });
  layer.on("click", ()=>{
    if (state.selected === layer){
      // unselect
      layer.setStyle(baseStyle(layer.feature));
      state.selected = null;
      renderDistrict(null,false);
      return;
    }
    if (state.selected){
      state.selected.setStyle(baseStyle(state.selected.feature));
    }
    state.selected = layer;
    selectStyle(layer);
    renderDistrict(layer.feature, true);
  });
}

/* =========================
   Layer value + styling
========================= */
function yearPop(p){
  if (state.year === 2014) return p.__pop2014;
  if (state.year === 2019) return p.__pop2019;
  return p.__pop2024;
}

function popChange(p){
  if (state.year === 2019){
    if (p.__pop2019==null || p.__pop2014==null) return null;
    return p.__pop2019 - p.__pop2014;
  }
  if (state.year === 2024){
    if (p.__pop2024==null || p.__pop2019==null) return null;
    return p.__pop2024 - p.__pop2019;
  }
  return null;
}

function popChangePct(p){
  if (state.year === 2019){
    if (p.__pop2019==null || p.__pop2014==null || p.__pop2014===0) return null;
    return (p.__pop2019 - p.__pop2014)/p.__pop2014;
  }
  if (state.year === 2024){
    if (p.__pop2024==null || p.__pop2019==null || p.__pop2019===0) return null;
    return (p.__pop2024 - p.__pop2019)/p.__pop2019;
  }
  return null;
}

function colorForFeature(p){
  switch (state.layer){
    case "pop":{
      const v = yearPop(p);
      const sc = state.scales.pop["y"+state.year] || [0,1];
      const t = (v==null) ? null : (v - sc[0])/(sc[1]-sc[0]);
      return (t==null || !Number.isFinite(t)) ? "#eef2f7" : seqColor(t, GREEN_L, GREEN_D);
    }
    case "popchg":{
      const v = popChange(p);
      const m = (state.year===2019) ? state.scales.popchg.prev2019 : state.scales.popchg.prev2024;
      return divergeColor(v, m);
    }
    case "popchgpct":{
      const v = popChangePct(p);
      const m = (state.year===2019) ? state.scales.popchgpct.prev2019 : state.scales.popchgpct.prev2024;
      return divergeColor(v, m);
    }
    case "e_win":{
      return electionColor(p.__e);
    }
    case "turnout":{
      const v = p.__turnout;
      const sc = state.scales.turnout || [0,1];
      const t = (v==null) ? null : (v - sc[0])/(sc[1]-sc[0]);
      return (t==null || !Number.isFinite(t)) ? "#eef2f7" : seqColor(t, TURN_L, TURN_D);
    }
    case "u18pct":{
      const v = p.__u18Pct;
      const sc = state.scales.u18pct || [0,1];
      const t = (v==null) ? null : (v - sc[0])/(sc[1]-sc[0]);
      return (t==null || !Number.isFinite(t)) ? "#eef2f7" : seqColor(t, U18_L, U18_D);
    }
    case "u18tot":{
      const v = p.__u18Tot;
      const sc = state.scales.u18tot || [0,1];
      const t = (v==null) ? null : (v - sc[0])/(sc[1]-sc[0]);
      return (t==null || !Number.isFinite(t)) ? "#eef2f7" : seqColor(t, U18_L, U18_D);
    }
    case "a18pct":{
      const v = p.__a18Pct;
      const sc = state.scales.a18pct || [0,1];
      const t = (v==null) ? null : (v - sc[0])/(sc[1]-sc[0]);
      return (t==null || !Number.isFinite(t)) ? "#eef2f7" : seqColor(t, A18_L, A18_D);
    }
    case "a18tot":{
      const v = p.__a18Tot;
      const sc = state.scales.a18tot || [0,1];
      const t = (v==null) ? null : (v - sc[0])/(sc[1]-sc[0]);
      return (t==null || !Number.isFinite(t)) ? "#eef2f7" : seqColor(t, A18_L, A18_D);
    }
    default:
      return "#eef2f7";
  }
}

/* =========================
   Legend rendering
========================= */
function setLegend(){
  const layer = LAYERS.find(x=>x.id===state.layer);
  document.getElementById("legendTitle").textContent = layer?.legend ?? "Legend";

  const bar = document.getElementById("legendBar");
  const labels = document.getElementById("legendLabels");
  const swatches = document.getElementById("partySwatches");

  swatches.style.display = "none";
  swatches.innerHTML = "";

  if (state.layer === "pop"){
    bar.style.background = `linear-gradient(90deg, ${GREEN_L}, ${GREEN_D})`;
    const [mn,mx] = state.scales.pop["y"+state.year] || [0,1];
    labels.innerHTML = `<span>${fmtInt(Math.round(mn))}</span><span>${fmtInt(Math.round(mx))}</span>`;
    return;
  }
  if (state.layer === "popchg"){
    bar.style.background = `linear-gradient(90deg, ${RED_D}, #ffffff, ${GREEN_D})`;
    const m = (state.year===2019) ? state.scales.popchg.prev2019 : state.scales.popchg.prev2024;
    labels.innerHTML = `<span>${fmtInt(-Math.round(m))}</span><span>${fmtInt(Math.round(m))}</span>`;
    return;
  }
  if (state.layer === "popchgpct"){
    bar.style.background = `linear-gradient(90deg, ${RED_D}, #ffffff, ${GREEN_D})`;
    const m = (state.year===2019) ? state.scales.popchgpct.prev2019 : state.scales.popchgpct.prev2024;
    labels.innerHTML = `<span>${( (-m)*100 ).toFixed(1).replace(".",",")}%</span><span>${( (m)*100 ).toFixed(1).replace(".",",")}%</span>`;
    return;
  }
  if (state.layer === "turnout"){
    bar.style.background = `linear-gradient(90deg, ${TURN_L}, ${TURN_D})`;
    const [mn,mx] = state.scales.turnout || [0,1];
    labels.innerHTML = `<span>${fmtPct(mn)}</span><span>${fmtPct(mx)}</span>`;
    return;
  }
  if (state.layer === "u18pct"){
    bar.style.background = `linear-gradient(90deg, ${U18_L}, ${U18_D})`;
    const [mn,mx] = state.scales.u18pct || [0,1];
    labels.innerHTML = `<span>${fmtPct(mn)}</span><span>${fmtPct(mx)}</span>`;
    return;
  }
  if (state.layer === "u18tot"){
    bar.style.background = `linear-gradient(90deg, ${U18_L}, ${U18_D})`;
    const [mn,mx] = state.scales.u18tot || [0,1];
    labels.innerHTML = `<span>${fmtInt(Math.round(mn))}</span><span>${fmtInt(Math.round(mx))}</span>`;
    return;
  }
  if (state.layer === "a18pct"){
    bar.style.background = `linear-gradient(90deg, ${A18_L}, ${A18_D})`;
    const [mn,mx] = state.scales.a18pct || [0,1];
    labels.innerHTML = `<span>${fmtPct(mn)}</span><span>${fmtPct(mx)}</span>`;
    return;
  }
  if (state.layer === "a18tot"){
    bar.style.background = `linear-gradient(90deg, ${A18_L}, ${A18_D})`;
    const [mn,mx] = state.scales.a18tot || [0,1];
    labels.innerHTML = `<span>${fmtInt(Math.round(mn))}</span><span>${fmtInt(Math.round(mx))}</span>`;
    return;
  }

  if (state.layer === "e_win"){
    // categorical legend: show top parties observed
    bar.style.background = "#eef2f7";
    labels.innerHTML = `<span>low margin → lighter</span><span>high margin → darker</span>`;

    const top = [...state.partyUniverse.entries()]
      .sort((a,b)=>b[1]-a[1])
      .slice(0,14)
      .map(([p])=>p);

    swatches.style.display = "block";
    for (const p of top){
      const row = document.createElement("div");
      row.className = "swatch";
      row.innerHTML = `
        <div class="swatchLeft">
          <div class="chip" style="background:${colorForParty(p)}"></div>
          <div class="swatchName">${p}</div>
        </div>
      `;
      swatches.appendChild(row);
    }
    return;
  }

  bar.style.background = "#eef2f7";
  labels.innerHTML = `<span>—</span><span>—</span>`;
}

/* =========================
   District info rendering
========================= */
function renderDistrict(feature, pinned){
  const elName = document.getElementById("dName");
  const elSub  = document.getElementById("dSub");
  const elBadge= document.getElementById("dBadge");

  if (!feature){
    elName.textContent = "Hover or click a district";
    elSub.textContent  = "Selection will pin details.";
    elBadge.textContent= "—";
    setValsNull();
    document.getElementById("winLine").textContent = "—";
    document.getElementById("topBars").innerHTML = "";
    return;
  }

  const p = feature.properties;
  const name = p.__distName;
  const prov = p.__provName;
  const plate= p.__plate;

  elName.textContent = name;
  elSub.textContent = pinned ? "Pinned (click again to unselect)." : `${prov} • hover for preview`;
  elBadge.textContent = `${prov} • ${String(plate).padStart(2,"0")}`;

  // population
  const popY = yearPop(p);
  const pop24 = p.__pop2024;
  const chg = popChange(p);
  const chgPct = popChangePct(p);

  document.getElementById("popYear").textContent = popY!=null ? fmtInt(popY) : "—";
  document.getElementById("pop2024").textContent = pop24!=null ? fmtInt(pop24) : "—";
  document.getElementById("popChg").textContent  = chg!=null ? (chg>=0?"+":"") + fmtInt(chg) : "—";
  document.getElementById("popChgPct").textContent = chgPct!=null ? ((chgPct>=0?"+":"") + (chgPct*100).toFixed(1).replace(".",",") + "%") : "—";

  const e = p.__e;
  document.getElementById("reg18").textContent = e?.registered!=null ? fmtInt(e.registered) : "—";
  document.getElementById("cast").textContent  = e?.cast!=null ? fmtInt(e.cast) : "—";
  document.getElementById("valid").textContent = e?.valid!=null ? fmtInt(e.valid) : "—";
  document.getElementById("turnout").textContent = p.__turnout!=null ? fmtPct(p.__turnout) : "—";

  document.getElementById("u18Total").textContent = p.__u18Tot!=null ? fmtInt(p.__u18Tot) : "—";
  document.getElementById("u18Pct").textContent   = p.__u18Pct!=null ? fmtPct(p.__u18Pct) : "—";
  document.getElementById("a18Total").textContent = p.__a18Tot!=null ? fmtInt(p.__a18Tot) : "—";
  document.getElementById("a18Pct").textContent   = p.__a18Pct!=null ? fmtPct(p.__a18Pct) : "—";

  // election line + bars
  const winLine = document.getElementById("winLine");
  const bars = document.getElementById("topBars");

  if (!e || !e.winner){
    winLine.textContent = "No election data for this district (missing province JSON or join mismatch).";
    bars.innerHTML = "";
    return;
  }

  const marginPct = (e.marginShare!=null) ? (e.marginShare*100).toFixed(1).replace(".",",")+"%" : "—";
  winLine.innerHTML = `<b>${e.winner}</b> leads <span class="tmuted">(margin ${marginPct})</span>`;

  const top = e.top || [];
  const maxV = top.length ? top[0][1] : 1;

  bars.innerHTML = "";
  for (const [party, votes] of top){
    const row = document.createElement("div");
    row.className = "barRow";
    const w = Math.max(1, Math.round((votes/maxV)*100));
    const col = colorForParty(party);

    row.innerHTML = `
      <div class="barName">${party}</div>
      <div class="bar"><div class="barFill" style="width:${w}%; background:${col};"></div></div>
      <div class="barVal">${fmtInt(votes)}</div>
    `;
    bars.appendChild(row);
  }
}

function setValsNull(){
  const ids = ["popYear","pop2024","popChg","popChgPct","reg18","cast","valid","turnout","u18Total","u18Pct","a18Total","a18Pct"];
  for (const id of ids) document.getElementById(id).textContent = "—";
}

/* =========================
   Tooltip
========================= */
const tipEl = document.getElementById("tip");
function tipShow(evt, feature){
  if (!evt || !feature) return;
  const p = feature.properties;
  const e = p.__e;
  const pop = yearPop(p);
  const line1 = `<b>${p.__distName}</b> <span class="tmuted">(${p.__provName})</span>`;
  let line2 = pop!=null ? `Pop: <b>${fmtInt(pop)}</b>` : `Pop: —`;

  if (state.layer === "e_win" && e?.winner){
    const m = e.marginShare!=null ? (e.marginShare*100).toFixed(1).replace(".",",")+"%" : "—";
    line2 = `Winner: <b>${e.winner}</b> <span class="tmuted">margin ${m}</span>`;
  } else if (state.layer === "turnout"){
    line2 = `Turnout: <b>${p.__turnout!=null ? fmtPct(p.__turnout) : "—"}</b>`;
  } else if (state.layer === "popchg"){
    const v = popChange(p);
    line2 = `Change: <b>${v!=null ? ((v>=0?"+":"")+fmtInt(v)) : "—"}</b>`;
  } else if (state.layer === "popchgpct"){
    const v = popChangePct(p);
    line2 = `Change: <b>${v!=null ? ((v>=0?"+":"")+(v*100).toFixed(1).replace(".",",")+"%") : "—"}</b>`;
  }

  tipEl.innerHTML = `${line1}<div class="tmuted" style="margin-top:2px;">${line2}</div>`;
  tipEl.style.opacity = "1";
  tipMove(evt);
}
function tipMove(evt){
  if (!evt) return;
  const wrap = document.getElementById("mapWrap").getBoundingClientRect();
  const x = evt.clientX - wrap.left;
  const y = evt.clientY - wrap.top;
  tipEl.style.left = x + "px";
  tipEl.style.top  = y + "px";
}
function tipHide(){
  tipEl.style.opacity = "0";
}

/* =========================
   Render / update
========================= */
function refreshMapStyles(){
  if (!geoLayer) return;
  geoLayer.setStyle(baseStyle);
  if (state.selected) selectStyle(state.selected);
  setLegend();
}

function populateLayerSelect(){
  const sel = document.getElementById("layerSel");
  sel.innerHTML = "";
  for (const l of LAYERS){
    const opt = document.createElement("option");
    opt.value = l.id;
    opt.textContent = l.name;
    sel.appendChild(opt);
  }
  sel.value = state.layer;
}

function noteLine(){
  const tiny = document.getElementById("tinyNote");
  if (["u18pct","u18tot","a18pct","a18tot","turnout","e_win"].includes(state.layer)){
    tiny.textContent = "Age/turnout use 2024 population + 2024 registered voters.";
  } else {
    tiny.textContent = "";
  }
}

/* =========================
   Loading pipeline
========================= */
async function loadAll(){
  document.getElementById("tinyNote").textContent = "Loading…";

  // 1) load population CSV
  const popText = await (await fetch(resolveUrl(FILE_POPCSV), {cache:"no-store"})).text();
  buildPopIndex(popText);

  // 2) load geojson
  state.geojson = await (await fetch(resolveUrl(FILE_GEOJSON), {cache:"no-store"})).json();

  // enrich geo features with plate/province keys
  state.features = state.geojson.features;
  for (const f of state.features){
    const p = f.properties || (f.properties={});
    const net = String(p.network ?? "");
    const m = net.match(/TR(\d{2})/i);
    const plate = m ? Number(m[1]) : null;
    p.__plate = plate;
    p.__provName = (plate && PLATE_TO_PROVINCE[plate]) ? PLATE_TO_PROVINCE[plate] : "Unknown";
    p.__distName = String(p.name ?? "").trim();
    p.__districtKey = keyify(p.__distName);
  }

  // 3) load elections (attempt all plates; only existing jsons will load)
  //    (this is the piece that fixes your “only Edirne” / “election disappeared” problem)
  await loadElectionsForAllPlates();

  // 4) join derived values
  for (const f of state.features) attachDerived(f);

  // 5) scales
  computeScales();

  // 6) init layer
  if (geoLayer) geoLayer.remove();
  geoLayer = L.geoJSON(state.geojson, {
    style: baseStyle,
    onEachFeature
  }).addTo(map);

  // Fit Turkey
  map.fitBounds(geoLayer.getBounds(), { padding:[20,20] });

  // UI
  populateLayerSelect();
  setLegend();
  noteLine();

  document.getElementById("tinyNote").textContent = "";
}

async function loadElectionsForAllPlates(){
  // limited concurrency so GitHub Pages doesn’t get hammered
  const plates = [];
  for (let plate=1; plate<=81; plate++) plates.push(plate);

  const concurrency = 6;
  let idx = 0;

  async function worker(){
    while (idx < plates.length){
      const plate = plates[idx++];
      const prov = PLATE_TO_PROVINCE[plate];
      if (!prov) continue;

      const json = await tryFetchElectionJson(prov, plate);
      if (!json) continue;

      const rows = parseElectionJson(json);

      for (const r of rows){
        // store primary key
        state.electIndex.set(uniqueKey(plate, r.districtKey), r);

        // store helpful aliases
        const dk = r.districtKey;
        const pk = keyify(prov);

        // "EDIRNE MERKEZ" -> also store "MERKEZ"
        if (dk.includes("MERKEZ")) state.electIndex.set(uniqueKey(plate, "MERKEZ"), r);

        // if district key starts with province name, store removed variant
        if (pk && dk.startsWith(pk+" ")){
          const removed = dk.replace(new RegExp(`^${pk}\\s+`), "").trim();
          if (removed) state.electIndex.set(uniqueKey(plate, removed), r);
        }

        // collect parties for legend
        if (r.winner){
          const w = r.winner.replace(/\s+/g," ").trim();
          state.partyUniverse.set(w, (state.partyUniverse.get(w)||0)+1);
        }
      }
    }
  }

  const workers = [];
  for (let i=0;i<concurrency;i++) workers.push(worker());
  await Promise.all(workers);
}

/* =========================
   UI wiring
========================= */
document.getElementById("layerSel").addEventListener("change", (e)=>{
  state.layer = e.target.value;
  refreshMapStyles();
  noteLine();
});

document.getElementById("yearSel").addEventListener("change", (e)=>{
  state.year = Number(e.target.value);
  refreshMapStyles();
});

document.getElementById("fitBtn").addEventListener("click", ()=>{
  if (geoLayer) map.fitBounds(geoLayer.getBounds(), { padding:[20,20] });
});

map.on("click", (e)=>{
  // click on empty map clears selection
  if (!e.originalEvent) return;
  // if clicked a district, its click handler will run; so only clear if no selected change
  // (Leaflet doesn't easily tell background clicks here, so we keep it simple: ctrl+click to clear)
});

document.addEventListener("keydown", (e)=>{
  if (e.key === "Escape") clearSelection();
});

/* =========================
   Boot
========================= */
(async ()=>{
  try{
    await loadAll();
  }catch(err){
    console.error(err);
    document.getElementById("tinyNote").textContent = "Load error. Check console + file names.";
  }
})();
</script>
</body>
</html>
