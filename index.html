<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Turkey Redistricter</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

  <style>
    :root{
      --bg: #f6f8fc;
      --panel: rgba(255,255,255,.94);
      --text: #0f172a;
      --muted: #475569;
      --muted2:#64748b;
      --border:#e2e8f0;
      --shadow: 0 18px 55px rgba(15,23,42,.10);
      --shadow2: 0 10px 30px rgba(15,23,42,.08);
      --radius: 18px;
      --radius2: 14px;
      --accent:#2563eb;
      --accent2:#0ea5e9;
      --chip:#eef2ff;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:
        radial-gradient(1200px 700px at 12% 8%, rgba(37,99,235,.08), transparent 60%),
        radial-gradient(900px 600px at 85% 15%, rgba(14,165,233,.10), transparent 55%),
        radial-gradient(800px 600px at 70% 85%, rgba(22,163,74,.08), transparent 55%),
        var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      overflow:hidden;
    }

    .app{
      height:100vh;
      display:grid;
      grid-template-columns: 1fr 400px;
      grid-template-rows: 1fr;     /* critical: give grid children real height */
      gap: 16px;
      padding: 16px;
      min-height: 0;
    }

    .map-wrap{
      position:relative;
      border-radius: var(--radius);
      overflow:hidden;
      box-shadow: var(--shadow);
      background:#fff;
      border:1px solid rgba(226,232,240,.80);
      min-height:0;
    }
    #map{
      position:absolute; inset:0;  /* critical: map fills container */
    }

    .topbar{
      position:absolute;
      z-index: 900;
      top: 14px; left: 14px; right: 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(226,232,240,.9);
      box-shadow: var(--shadow2);
      backdrop-filter: blur(10px);
    }

    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      min-width: 240px;
    }
    .dot{
      width:10px; height:10px; border-radius:999px;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      box-shadow: 0 0 0 4px rgba(37,99,235,.14);
    }
    .brand .title{
      font-weight: 950;
      letter-spacing:-0.02em;
      line-height:1.05;
    }
    .brand .subtitle{
      font-size:12px;
      color: var(--muted2);
      margin-top:2px;
    }

    .controls{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .control{
      display:flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid rgba(226,232,240,.95);
      background: rgba(248,250,252,.90);
    }
    .control label{
      font-size:12px;
      color: var(--muted);
      font-weight: 800;
    }
    select{
      appearance:none;
      border:0;
      background: transparent;
      font-weight:950;
      color: var(--text);
      padding: 4px 28px 4px 10px;
      border-radius: 999px;
      outline:none;
      cursor:pointer;
      background-image:
        linear-gradient(45deg, transparent 50%, #64748b 50%),
        linear-gradient(135deg, #64748b 50%, transparent 50%);
      background-position:
        calc(100% - 16px) 50%,
        calc(100% - 11px) 50%;
      background-size: 5px 5px, 5px 5px;
      background-repeat:no-repeat;
    }

    .btn{
      border:none;
      cursor:pointer;
      font-weight:950;
      padding: 10px 14px;
      border-radius: 999px;
      background: var(--text);
      color:#fff;
      box-shadow: 0 10px 22px rgba(15,23,42,.14);
      transition: transform .12s ease, box-shadow .12s ease, opacity .12s ease;
      user-select:none;
    }
    .btn:hover{ transform: translateY(-1px); box-shadow: 0 14px 28px rgba(15,23,42,.16); }
    .btn:active{ transform: translateY(0px); opacity:.92; }

    .hint{
      font-size: 12px;
      color: var(--muted2);
      font-weight: 800;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(241,245,249,.88);
      border:1px solid rgba(226,232,240,.88);
      white-space:nowrap;
      max-width: 520px;
      overflow:hidden;
      text-overflow: ellipsis;
    }

    .panel{
      height:100%;
      display:flex;
      flex-direction:column;
      gap: 14px;
      min-height:0;
    }
    .card{
      background: var(--panel);
      border: 1px solid rgba(226,232,240,.9);
      border-radius: var(--radius);
      box-shadow: var(--shadow2);
      padding: 14px;
      overflow:hidden;
    }
    .card h3{
      margin:0 0 10px 0;
      font-size: 14px;
      letter-spacing: -0.01em;
      font-weight: 950;
    }
    .muted{ color: var(--muted2); font-size: 12px; line-height:1.35; font-weight:800; }

    .legendbar{
      height: 10px;
      border-radius: 999px;
      border: 1px solid rgba(15,23,42,.10);
      margin: 10px 0 8px;
    }
    .legendlabels{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size:12px;
      color: var(--muted);
      font-weight:900;
    }

    .district-header{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }
    .district-name{
      font-size: 16px;
      font-weight: 1000;
      letter-spacing: -0.02em;
      line-height:1.1;
      margin:0;
    }
    .district-sub{
      margin-top: 4px;
      font-size:12px;
      color: var(--muted);
      font-weight:900;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding: 4px 10px;
      background: var(--chip);
      border: 1px solid rgba(99,102,241,.20);
      color: #3730a3;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 950;
    }
    .chip .sw{ width:10px; height:10px; border-radius: 3px; background:#94a3b8; }

    .clear-btn{
      border:none;
      cursor:pointer;
      font-weight:1000;
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(241,245,249,.96);
      border: 1px solid rgba(226,232,240,.96);
      color: var(--text);
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top: 12px;
    }
    .metric{
      padding: 10px 10px;
      border-radius: var(--radius2);
      background: rgba(248,250,252,.94);
      border: 1px solid rgba(226,232,240,.94);
    }
    .metric .k{
      font-size: 11px;
      color: var(--muted2);
      font-weight: 950;
      letter-spacing: .02em;
      text-transform: uppercase;
    }
    .metric .v{
      margin-top: 5px;
      font-size: 14px;
      font-weight: 1000;
      letter-spacing: -0.01em;
    }
    .metric .s{
      margin-top: 2px;
      font-size: 12px;
      color: var(--muted);
      font-weight: 850;
    }

    .section-title{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-top: 10px;
      padding-top: 12px;
      border-top: 1px solid rgba(226,232,240,.96);
    }
    .section-title h4{
      margin:0;
      font-size: 13px;
      font-weight: 1000;
      letter-spacing: -0.01em;
    }
    .section-title .small{
      font-size: 12px;
      color: var(--muted2);
      font-weight: 900;
      white-space:nowrap;
    }

    .bars{
      margin-top: 10px;
      display:flex;
      flex-direction:column;
      gap: 8px;
    }
    .bar-row{
      display:grid;
      grid-template-columns: 120px 1fr 150px;
      gap:10px;
      align-items:center;
    }
    .bar-row .pname{
      display:flex;
      align-items:center;
      gap:8px;
      font-weight: 1000;
      font-size: 12px;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .swatch{
      width:10px; height:10px; border-radius: 3px;
      box-shadow: 0 0 0 3px rgba(148,163,184,.20);
      flex:0 0 auto;
    }
    .track{
      height: 10px;
      border-radius: 999px;
      background: rgba(226,232,240,.92);
      border: 1px solid rgba(148,163,184,.18);
      overflow:hidden;
    }
    .fill{
      height:100%;
      border-radius: 999px;
      width: 0%;
      transition: width .18s ease;
    }
    .bar-row .val{
      font-variant-numeric: tabular-nums;
      text-align:right;
      font-size: 12px;
      color: var(--muted);
      font-weight: 950;
      white-space:nowrap;
    }

    .leaflet-control-zoom{
      border-radius: 14px !important;
      overflow:hidden;
      box-shadow: var(--shadow2);
      border: 1px solid rgba(226,232,240,.96);
    }
    .leaflet-bar a{
      background: rgba(255,255,255,.96) !important;
      color: var(--text) !important;
    }

    .district-tooltip{
      background: rgba(255,255,255,.96);
      border: 1px solid rgba(226,232,240,.96);
      color: var(--text);
      border-radius: 12px;
      box-shadow: var(--shadow2);
      padding: 8px 10px;
      font-weight: 1000;
      letter-spacing: -0.01em;
    }
    .district-tooltip .t2{
      display:block;
      margin-top:2px;
      font-size: 12px;
      color: var(--muted);
      font-weight: 900;
    }
  </style>
</head>

<body>
  <div class="app">
    <div class="map-wrap">
      <div class="topbar">
        <div class="brand">
          <div class="dot"></div>
          <div>
            <div class="title">Turkey Redistricter</div>
            <div class="subtitle">all districts • elections • population • turnout • age</div>
          </div>
        </div>

        <div class="controls">
          <div class="control">
            <label for="layerSel">Layer</label>
            <select id="layerSel"></select>
          </div>
          <div class="control">
            <label for="yearSel">Year</label>
            <select id="yearSel">
              <option value="2024" selected>2024</option>
              <option value="2019">2019</option>
              <option value="2014">2014</option>
            </select>
          </div>
          <button class="btn" id="fitBtn" title="Fit Turkey">Fit</button>
          <div class="hint" id="hintText" title="Info">
            Hover to preview. Click to pin/unpin. (Turnout & age use 2024 pop + 2024 registered.)
          </div>
        </div>
      </div>

      <div id="map"></div>
    </div>

    <div class="panel">
      <div class="card">
        <h3>Legend</h3>
        <div class="muted" id="legendDesc">Population total (light green → dark green).</div>
        <div class="legendbar" id="legendBar"></div>
        <div class="legendlabels"><span id="legMin">—</span><span id="legMax">—</span></div>
      </div>

      <div class="card">
        <div class="district-header">
          <div>
            <p class="district-name" id="dName">District</p>
            <div class="district-sub" id="dSub">Hover or click a district.</div>
          </div>
          <button class="clear-btn" id="clearBtn" style="display:none;">Clear</button>
        </div>

        <div class="grid" id="metricsGrid"></div>

        <div class="section-title">
          <h4>Election (winner)</h4>
          <div class="small">Winner shading = lighter when margin is small</div>
        </div>

        <div class="muted" id="eNote" style="margin-top:6px;">Hover or click a district to see details.</div>
        <div class="bars" id="bars" style="display:none;"></div>
      </div>
    </div>
  </div>

<script>
/* ============================= CONFIG ============================= */
const FILE_GEOJSON = "turkey-admin-level-6.geojson";
const FILE_POP_CSV = "province_district_2014_2019_2024.csv";

/* ============================= TURKEY PLATES ============================= */
const PLATE_TO_PROVINCE_TR = {
  1:"Adana",2:"Adıyaman",3:"Afyonkarahisar",4:"Ağrı",5:"Amasya",6:"Ankara",7:"Antalya",8:"Artvin",9:"Aydın",10:"Balıkesir",
  11:"Bilecik",12:"Bingöl",13:"Bitlis",14:"Bolu",15:"Burdur",16:"Bursa",17:"Çanakkale",18:"Çankırı",19:"Çorum",20:"Denizli",
  21:"Diyarbakır",22:"Edirne",23:"Elazığ",24:"Erzincan",25:"Erzurum",26:"Eskişehir",27:"Gaziantep",28:"Giresun",29:"Gümüşhane",30:"Hakkâri",
  31:"Hatay",32:"Isparta",33:"Mersin",34:"İstanbul",35:"İzmir",36:"Kars",37:"Kastamonu",38:"Kayseri",39:"Kırklareli",40:"Kırşehir",
  41:"Kocaeli",42:"Konya",43:"Kütahya",44:"Malatya",45:"Manisa",46:"Kahramanmaraş",47:"Mardin",48:"Muğla",49:"Muş",50:"Nevşehir",
  51:"Niğde",52:"Ordu",53:"Rize",54:"Sakarya",55:"Samsun",56:"Siirt",57:"Sinop",58:"Sivas",59:"Tekirdağ",60:"Tokat",
  61:"Trabzon",62:"Tunceli",63:"Şanlıurfa",64:"Uşak",65:"Van",66:"Yozgat",67:"Zonguldak",68:"Aksaray",69:"Bayburt",70:"Karaman",
  71:"Kırıkkale",72:"Batman",73:"Şırnak",74:"Bartın",75:"Ardahan",76:"Iğdır",77:"Yalova",78:"Karabük",79:"Kilis",80:"Osmaniye",81:"Düzce"
};

/* ============================= NORMALIZATION ============================= */
const TR_CHARMAP = {
  "İ":"I","I":"I","ı":"i",
  "Ş":"S","ş":"s",
  "Ğ":"G","ğ":"g",
  "Ü":"U","ü":"u",
  "Ö":"O","ö":"o",
  "Ç":"C","ç":"c",
  "Â":"A","â":"a","Î":"I","î":"i","Û":"U","û":"u"
};

function foldTR(str){
  const s = (str ?? "").toString().replace(/[İIıŞşĞğÜüÖöÇçÂâÎîÛû]/g, ch => TR_CHARMAP[ch] || ch);
  return s.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}
function keyify(str){
  return foldTR(str)
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, " ")
    .trim()
    .replace(/\s+/g, "-");
}
function cleanLabel(str){ return (str ?? "").toString().replace(/\s+/g, " ").trim(); }

function provinceFileName(trName){
  const folded = foldTR(trName).toLowerCase().replace(/[^a-z0-9]/g,"");
  return folded ? (folded[0].toUpperCase() + folded.slice(1)) : "Province";
}

/* ============================= SMART PATHS (THE FIX) ============================= */
/**
 * GitHub Pages can serve from / (root) or /docs.
 * And your index may be /repo/ or /repo/docs/.
 * This tries the likely correct URLs automatically.
 */
function repoBasePath(){
  const parts = window.location.pathname.split("/").filter(Boolean);
  // /<user>.github.io/<repo>/...
  if (window.location.hostname.endsWith("github.io") && parts.length >= 1){
    return "/" + parts[0] + "/"; // repo root
  }
  return "/"; // non-GH hosting
}
function currentDirUrl(){
  const u = new URL(window.location.href);
  u.hash = ""; u.search = "";
  // ensure ends with /
  if (!u.pathname.endsWith("/")) u.pathname = u.pathname.substring(0, u.pathname.lastIndexOf("/")+1);
  return u.toString();
}
function buildCandidates(file){
  const baseRepo = repoBasePath();                // "/re-ilce/"
  const here = currentDirUrl();                   // ".../re-ilce/" or ".../re-ilce/docs/"
  const uHere = new URL(file, here).toString();   // relative to current directory
  const uUp1  = new URL("../" + file, here).toString();
  const uUp2  = new URL("../../" + file, here).toString();

  const uRepoRoot = new URL(file.replace(/^\.\//,""), window.location.origin + baseRepo).toString();
  const uRepoDocs = new URL("docs/" + file.replace(/^\.\//,""), window.location.origin + baseRepo).toString();

  // de-dup while preserving order
  const set = new Set();
  const out = [];
  for (const u of [uHere, uRepoRoot, uRepoDocs, uUp1, uUp2]){
    if (!set.has(u)){
      set.add(u); out.push(u);
    }
  }
  return out;
}

async function fetchFirstOk(file, asJson){
  const candidates = buildCandidates(file);
  let lastErr = null;

  for (const url of candidates){
    try{
      const res = await fetch(url, { cache:"no-store" });
      if (!res.ok){
        lastErr = `HTTP ${res.status} ${res.statusText} @ ${url}`;
        continue;
      }
      if (asJson){
        try { return await res.json(); }
        catch(e){ lastErr = `JSON parse failed @ ${url}`; continue; }
      } else {
        return await res.text();
      }
    }catch(e){
      lastErr = `Network/CORS error @ ${url}`;
    }
  }
  throw new Error(`Failed to fetch "${file}". Tried:\n- ${candidates.join("\n- ")}\nLast: ${lastErr}`);
}

/* ============================= NUMBERS ============================= */
function parseTrNumber(x){
  if (x === null || x === undefined) return null;
  let s = String(x).trim();
  if (!s) return null;
  s = s.replace(/\s+/g,"").replace(/%/g,"");

  if (s.includes(".") && s.includes(",")) {
    s = s.replace(/\./g,"").replace(/,/g,".");
  } else if (s.includes(".")) {
    const parts = s.split(".");
    if (parts.length > 2) s = parts.join("");
    else if (parts.length === 2 && parts[1].length === 3) s = parts.join("");
  } else if (s.includes(",")) {
    const parts = s.split(",");
    if (parts.length === 2 && parts[1].length !== 3) s = parts.join(".");
    else s = parts.join("");
  }

  s = s.replace(/[^0-9.\-]/g,"");
  const n = Number(s);
  return Number.isFinite(n) ? n : null;
}
function fmtInt(n){ return Number.isFinite(n) ? Math.round(n).toLocaleString("tr-TR") : "—"; }
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

/* ============================= COLORS ============================= */
function hexToRgb(hex){
  const h = hex.replace("#","").trim();
  const full = (h.length===3) ? h.split("").map(c=>c+c).join("") : h;
  const n = parseInt(full,16);
  return {r:(n>>16)&255, g:(n>>8)&255, b:n&255};
}
function rgbToHex({r,g,b}){
  const to = v => v.toString(16).padStart(2,"0");
  return "#" + to(r) + to(g) + to(b);
}
function mix(hexA, hexB, t){
  const a=hexToRgb(hexA), b=hexToRgb(hexB);
  return rgbToHex({
    r: Math.round(a.r + (b.r-a.r)*t),
    g: Math.round(a.g + (b.g-a.g)*t),
    b: Math.round(a.b + (b.b-a.b)*t),
  });
}
function seqGreen(t){ return mix("#dcfce7", "#14532d", clamp(t,0,1)); }
function divRedWhiteGreen(t){
  const x = clamp(t,-1,1);
  if (x < 0) return mix("#7f1d1d", "#f8fafc", (x+1));
  return mix("#f8fafc", "#166534", x);
}
function hashColor(s){
  const k = keyify(s);
  let h = 0;
  for (let i=0;i<k.length;i++) h = (h*31 + k.charCodeAt(i)) >>> 0;
  const palette = ["#1d4ed8","#6d28d9","#15803d","#c2410c","#be185d","#0f766e","#b91c1c","#a16207"];
  return mix(palette[h % palette.length], "#ffffff", 0.10);
}

/* Party colors (strong + aliases) */
const PARTY_BASE = new Map([
  ["chp", "#e11d48"],
  ["ak-parti", "#f59e0b"],
  ["mhp", "#991b1b"],
  ["iyi-parti", "#2563eb"],
  ["dem-parti", "#7c3aed"],
  ["hdp", "#7c3aed"],
  ["yesil-sol-parti", "#16a34a"],
  ["tip", "#dc2626"],
  ["zafer-partisi", "#0f172a"],
  ["yeniden-refah", "#16a34a"],
  ["saadet", "#0ea5e9"],
  ["deva", "#3b82f6"],
  ["gelecek", "#22c55e"],
  ["bbp", "#ef4444"]
]);

function partyKeyAlias(raw){
  const k = keyify(raw);
  if (PARTY_BASE.has(k)) return k;
  if (k.includes("cumhuriyet") && k.includes("halk")) return "chp";
  if (k.includes("adalet") && k.includes("kalkinma")) return "ak-parti";
  if (k.includes("ak-parti")) return "ak-parti";
  if (k.includes("akparti")) return "ak-parti";
  if (k.includes("milliyetci") && k.includes("hareket")) return "mhp";
  if (k.includes("iyi")) return "iyi-parti";
  if (k.includes("dem") && k.includes("parti")) return "dem-parti";
  if (k.includes("yesil") && k.includes("sol")) return "yesil-sol-parti";
  if (k.includes("isci") && k.includes("parti")) return "tip";
  if (k.includes("zafer")) return "zafer-partisi";
  if (k.includes("yeniden") && k.includes("refah")) return "yeniden-refah";
  return k;
}
function partyColor(raw){
  const kk = partyKeyAlias(raw);
  return PARTY_BASE.get(kk) || hashColor(raw);
}

/* ============================= LAYERS ============================= */
const LAYER_DEFS = [
  { id:"election_winner", label:"Election: winner (margin shading)", kind:"election" },

  { id:"pop_total", label:"Population: total", kind:"seq" },
  { id:"pop_change", label:"Population: change (abs)", kind:"div" },
  { id:"pop_change_pct", label:"Population: change (%)", kind:"div" },

  { id:"turnout", label:"Turnout (% cast / registered)", kind:"seq_turnout" },

  { id:"age_u18_pct", label:"Age: 0–18 (%)", kind:"seq" },
  { id:"age_u18_total", label:"Age: 0–18 (total)", kind:"seq" },
  { id:"age_18p_pct", label:"Age: 18+ (%)", kind:"seq" },
  { id:"age_18p_total", label:"Age: 18+ (total)", kind:"seq" },
];

let activeLayerId = "election_winner";
let activeYear = 2024;

const popByKey = new Map();      // "plate:districtKey" => {2014,2019,2024}
const electionByKey = new Map(); // "plate:districtKey" => election object

/* ============================= UI REFS ============================= */
const elLayer = document.getElementById("layerSel");
const elYear  = document.getElementById("yearSel");
const elFit   = document.getElementById("fitBtn");
const elHint  = document.getElementById("hintText");

const elLegendDesc = document.getElementById("legendDesc");
const elLegendBar  = document.getElementById("legendBar");
const elLegMin     = document.getElementById("legMin");
const elLegMax     = document.getElementById("legMax");

const elDName = document.getElementById("dName");
const elDSub  = document.getElementById("dSub");
const elGrid  = document.getElementById("metricsGrid");
const elBars  = document.getElementById("bars");
const elENote = document.getElementById("eNote");
const elClear = document.getElementById("clearBtn");

/* Populate layer selector */
for (const def of LAYER_DEFS){
  const opt = document.createElement("option");
  opt.value = def.id;
  opt.textContent = def.label;
  if (def.id === activeLayerId) opt.selected = true;
  elLayer.appendChild(opt);
}

/* ============================= MAP INIT ============================= */
const map = L.map("map", { zoomControl:true, preferCanvas:true });
L.tileLayer("https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png", {
  attribution: '&copy; OpenStreetMap &copy; CARTO',
  maxZoom: 18
}).addTo(map);

map.setView([39.0, 35.0], 6);

function hardInvalidate(){ try{ map.invalidateSize(true); }catch{} }
window.addEventListener("resize", () => setTimeout(hardInvalidate, 0));
setTimeout(hardInvalidate, 0);

/* ============================= PROVINCE FILES (81 attempts) ============================= */
const PROVINCE_FILES = Object.entries(PLATE_TO_PROVINCE_TR).map(([plate, tr]) => ({
  plate: Number(plate),
  file: provinceFileName(tr) + ".json"
}));

/* ============================= STATE ============================= */
let geoLayer = null;
let turkeyBounds = null;
let hoverLayer = null;
let selectedLayer = null;

let cachedScaleKey = null;
let cachedScale = null;

/* ============================= EVENTS ============================= */
elLayer.addEventListener("change", () => {
  activeLayerId = elLayer.value;
  cachedScaleKey = null; cachedScale = null;
  refreshStyles();
  refreshLegend();
  refreshInfoPanel();
});
elYear.addEventListener("change", () => {
  activeYear = Number(elYear.value);
  cachedScaleKey = null; cachedScale = null;
  refreshStyles();
  refreshLegend();
  refreshInfoPanel();
});
elFit.addEventListener("click", () => {
  if (turkeyBounds) map.fitBounds(turkeyBounds, { padding:[18,18] });
});
elClear.addEventListener("click", () => unselect());

/* ============================= DATA LOAD ============================= */
(async function boot(){
  try{
    // load population
    const csvText = await fetchFirstOk(FILE_POP_CSV, false);
    parsePopulationCsv(csvText);
  }catch(e){
    console.warn(e);
    elHint.textContent = "Population CSV failed to load. Check file name/path.";
  }

  let provincesLoaded = 0;
  // limit concurrency so your browser doesn’t scream
  provincesLoaded = await loadElectionAllProvincesLimited(8);

  try{
    const geo = await fetchFirstOk(FILE_GEOJSON, true);
    drawGeo(geo);
  }catch(e){
    console.error(e);
    elHint.textContent = "GeoJSON failed to load. Open console for exact URL tried.";
    return;
  }

  refreshLegend();
  refreshInfoPanel(null);
  elHint.textContent = `Ready. Provinces loaded: ${provincesLoaded}. Hover to preview, click to pin/unpin.`;
  setTimeout(hardInvalidate, 60);
  setTimeout(hardInvalidate, 250);
})();

/* ============================= POP CSV ============================= */
function parsePopulationCsv(txt){
  const lines = txt.trim().split(/\r?\n/);
  if (lines.length < 2) return;

  const header = lines[0].split(",").map(h=>h.trim());
  const idx = {
    province: header.indexOf("Province"),
    district: header.indexOf("District"),
    y2014: header.indexOf("2014"),
    y2019: header.indexOf("2019"),
    y2024: header.indexOf("2024")
  };

  const provinceToPlate = new Map();
  for (const [plateStr, trName] of Object.entries(PLATE_TO_PROVINCE_TR)){
    const plate = Number(plateStr);
    provinceToPlate.set(keyify(trName), plate);
    provinceToPlate.set(keyify(foldTR(trName)), plate);
    provinceToPlate.set(keyify(provinceFileName(trName)), plate);
  }
  // common ASCII variants
  provinceToPlate.set(keyify("Sanliurfa"), 63);
  provinceToPlate.set(keyify("Kahramanmaras"), 46);
  provinceToPlate.set(keyify("Igdir"), 76);
  provinceToPlate.set(keyify("Kirikkale"), 71);
  provinceToPlate.set(keyify("Kirsehir"), 40);

  for (let i=1;i<lines.length;i++){
    const row = lines[i].split(",");
    const prov = row[idx.province]?.trim();
    const dist = row[idx.district]?.trim();
    if (!prov || !dist) continue;

    const plate = provinceToPlate.get(keyify(prov));
    if (!plate) continue;

    const key = plate + ":" + keyify(dist);
    const y2014 = Number(row[idx.y2014]);
    const y2019 = Number(row[idx.y2019]);
    const y2024 = Number(row[idx.y2024]);

    popByKey.set(key, {
      2014: Number.isFinite(y2014) ? y2014 : null,
      2019: Number.isFinite(y2019) ? y2019 : null,
      2024: Number.isFinite(y2024) ? y2024 : null
    });
  }
}

/* ============================= ELECTION JSON LOAD ============================= */
async function loadElectionAllProvincesLimited(limit){
  let loaded = 0;
  let i = 0;

  async function worker(){
    while (i < PROVINCE_FILES.length){
      const mine = i++;
      const p = PROVINCE_FILES[mine];
      try{
        const json = await fetchFirstOk(p.file, true);
        parseProvinceElectionJson(p.plate, json);
        loaded++;
      }catch(_e){
        // ignore missing province files (404) silently
      }
    }
  }

  const workers = Array.from({length:limit}, () => worker());
  await Promise.all(workers);
  return loaded;
}

function getField(row, names){
  for (const n of names){
    if (row && Object.prototype.hasOwnProperty.call(row, n)) return row[n];
  }
  return undefined;
}

function parseProvinceElectionJson(plate, json){
  if (!Array.isArray(json)) return;

  for (const row of json){
    const ilceId  = getField(row, ["Ilce Id","İlce Id","İlçe Id","İlçe Id ","IlceId","İlçeId"]);
    const ilceAdi = getField(row, ["Ilce Adi","İlçe Adı","Ilce Adı","İlçe Adi","IlceAdi","İlçeAdı","İlçe Adi "]);

    const idStr = cleanLabel(ilceId);
    const nameStr = cleanLabel(ilceAdi);
    if (!nameStr) continue;

    // Skip header/percent rows
    if (!idStr || keyify(idStr) === "oy-orani") continue;
    const idDigits = foldTR(idStr).replace(/\D/g,"");
    if (!idDigits || !/^\d+$/.test(idDigits)) continue;

    const registered = parseTrNumber(getField(row, ["Kayitli Secmen Sayisi","Kayıtlı Seçmen Sayısı","KayitliSecmenSayisi","KayıtlıSeçmenSayısı"]));
    const cast      = parseTrNumber(getField(row, ["Oy Kullanan Secmen Sayisi","Oy Kullanan Seçmen Sayısı","OyKullananSecmenSayisi"]));
    const valid     = parseTrNumber(getField(row, ["Gecerli Oy Toplami","Geçerli Oy Toplamı","GecerliOyToplami"]));

    const votes = new Map();
    const skipKeys = new Set([
      "Ilce Id","İlce Id","İlçe Id","İlçe Id ","IlceId","İlçeId",
      "Ilce Adi","İlçe Adı","Ilce Adı","İlçe Adi","IlceAdi","İlçeAdı","İlçe Adi ",
      "Belde Adi","Belde Adı",
      "Kayitli Secmen Sayisi","Kayıtlı Seçmen Sayısı","KayitliSecmenSayisi","KayıtlıSeçmenSayısı",
      "Oy Kullanan Secmen Sayisi","Oy Kullanan Seçmen Sayısı","OyKullananSecmenSayisi",
      "Gecerli Oy Toplami","Geçerli Oy Toplamı","GecerliOyToplami"
    ]);

    for (const [k,v] of Object.entries(row)){
      if (skipKeys.has(k)) continue;
      const kk = cleanLabel(k);
      if (!kk) continue;
      if (keyify(kk) === "oy-orani") continue;

      const n = parseTrNumber(v);
      if (!Number.isFinite(n) || n <= 0) continue;
      votes.set(kk, n);
    }

    const sorted = [...votes.entries()].sort((a,b)=>b[1]-a[1]);
    const winner = sorted[0]?.[0] ?? null;
    const winnerVotes = sorted[0]?.[1] ?? null;
    const runnerUp = sorted[1]?.[0] ?? null;
    const runnerUpVotes = sorted[1]?.[1] ?? null;

    const denom = (Number.isFinite(valid) && valid>0) ? valid :
      (sorted.reduce((s,[_p,val])=>s+val,0) || null);

    const margin = (Number.isFinite(winnerVotes) && Number.isFinite(runnerUpVotes) && Number.isFinite(denom) && denom>0)
      ? (winnerVotes-runnerUpVotes)/denom
      : null;

    const key = plate + ":" + keyify(nameStr);
    electionByKey.set(key, { plate, districtNameRaw:nameStr, registered, cast, valid, denom, votes, winner, runnerUp, margin });
  }
}

/* ============================= GEO DRAW ============================= */
function featurePlate(feature){
  const net = feature?.properties?.network || "";
  const m = String(net).match(/TR(\d+)/i);
  return m ? Number(m[1]) : null;
}
function provinceNameFromPlate(plate){
  return PLATE_TO_PROVINCE_TR[plate] || ("Plate " + plate);
}
function featureKey(feature){
  const plate = featurePlate(feature);
  const dist = feature?.properties?.name || "";
  return (plate ?? "null") + ":" + keyify(dist);
}
function displayDistrictTitle(feature){
  const plate = featurePlate(feature);
  const prov = plate ? provinceNameFromPlate(plate) : "Unknown";
  const dist = feature?.properties?.name || "—";
  return `<span>${dist}</span><span class="t2">${prov} • ${plate ?? "—"}</span>`;
}

function drawGeo(gj){
  if (geoLayer) geoLayer.remove();

  geoLayer = L.geoJSON(gj, {
    // remove “map tacks”: ignore point geometries
    filter: (feature) => {
      const t = feature?.geometry?.type;
      return t === "Polygon" || t === "MultiPolygon";
    },
    style: baseStyle,
    onEachFeature: (feature, layer) => {
      layer.bindTooltip(displayDistrictTitle(feature), { sticky:true, className:"district-tooltip" });

      layer.on("mouseover", () => {
        hoverLayer = layer;
        if (hoverLayer !== selectedLayer) hoverLayer.setStyle(hoverStyle());
        if (!selectedLayer) refreshInfoPanel(feature);
      });

      layer.on("mouseout", () => {
        if (hoverLayer && hoverLayer !== selectedLayer) geoLayer.resetStyle(hoverLayer);
        hoverLayer = null;
        if (!selectedLayer) refreshInfoPanel(null);
      });

      layer.on("click", () => {
        if (selectedLayer === layer) { unselect(); return; }
        select(layer, feature);
      });
    }
  }).addTo(map);

  turkeyBounds = geoLayer.getBounds();
  map.fitBounds(turkeyBounds, { padding:[18,18] });
  hardInvalidate();
}

/* ============================= LAYER VALUES ============================= */
function prevYear(y){ return (y===2024)?2019 : (y===2019)?2014 : null; }

function dataForFeature(feature){
  const key = featureKey(feature);
  return {
    key,
    plate: featurePlate(feature),
    pop: popByKey.get(key) || null,
    elec: electionByKey.get(key) || null,
    feature
  };
}

function valueForLayer(d){
  const def = LAYER_DEFS.find(x=>x.id===activeLayerId);
  if (!def) return null;
  if (def.kind === "election") return null;

  if (activeLayerId === "pop_total"){
    return d.pop ? d.pop[String(activeYear)] : null;
  }
  if (activeLayerId === "pop_change"){
    const py = prevYear(activeYear);
    if (!d.pop || !py) return null;
    const a = d.pop[String(activeYear)];
    const b = d.pop[String(py)];
    if (!Number.isFinite(a) || !Number.isFinite(b)) return null;
    return a - b;
  }
  if (activeLayerId === "pop_change_pct"){
    const py = prevYear(activeYear);
    if (!d.pop || !py) return null;
    const a = d.pop[String(activeYear)];
    const b = d.pop[String(py)];
    if (!Number.isFinite(a) || !Number.isFinite(b) || b === 0) return null;
    return (a - b) / b;
  }

  if (activeLayerId === "turnout"){
    const reg = d.elec?.registered;
    const cast = d.elec?.cast;
    if (!Number.isFinite(reg) || !Number.isFinite(cast) || reg <= 0) return null;
    return cast / reg;
  }

  const pop2024 = d.pop ? d.pop["2024"] : null;
  const reg = d.elec?.registered;
  if (!Number.isFinite(pop2024) || pop2024 <= 0 || !Number.isFinite(reg) || reg < 0) return null;

  const u18 = clamp(pop2024 - reg, 0, pop2024);
  const p18 = clamp(reg, 0, pop2024);

  if (activeLayerId === "age_u18_pct") return u18 / pop2024;
  if (activeLayerId === "age_u18_total") return u18;
  if (activeLayerId === "age_18p_pct") return p18 / pop2024;
  if (activeLayerId === "age_18p_total") return p18;

  return null;
}

/* ============================= SCALE / LEGEND ============================= */
function getScaleForActiveLayer(){
  const k = activeLayerId + ":" + activeYear;
  if (k === cachedScaleKey && cachedScale) return cachedScale;

  const def = LAYER_DEFS.find(x=>x.id===activeLayerId);
  if (!def || def.kind === "election"){
    cachedScaleKey = k;
    cachedScale = { kind:"none", min:0, max:1, absMax:1 };
    return cachedScale;
  }

  const values = [];
  geoLayer?.eachLayer(l => {
    const d = dataForFeature(l.feature);
    const v = valueForLayer(d);
    if (Number.isFinite(v)) values.push(v);
  });

  let scale;
  if (!values.length){
    scale = { kind: (activeLayerId==="turnout" ? "seq_turnout" : "seq"), min:0, max:1, absMax:1 };
  } else if (activeLayerId === "pop_change" || activeLayerId === "pop_change_pct"){
    const absMax = Math.max(...values.map(v => Math.abs(v))) || 1;
    scale = { kind:"div", absMax, min:-absMax, max:absMax };
  } else if (activeLayerId === "turnout"){
    const min = Math.min(...values), max = Math.max(...values);
    scale = { kind:"seq_turnout", min, max, absMax:1 };
  } else {
    const min = Math.min(...values), max = Math.max(...values);
    scale = { kind:"seq", min, max, absMax:1 };
  }

  cachedScaleKey = k;
  cachedScale = scale;
  return scale;
}

function refreshLegend(){
  const def = LAYER_DEFS.find(x=>x.id===activeLayerId);
  const scale = getScaleForActiveLayer();

  if (def?.kind === "election"){
    elLegendDesc.textContent = "Winner color (party). Lighter shade = smaller winning margin.";
    elLegendBar.style.background = "linear-gradient(90deg, #ffffff, #e2e8f0)";
    elLegMin.textContent = "Close";
    elLegMax.textContent = "Landslide";
    return;
  }

  if (activeLayerId === "pop_total"){
    elLegendDesc.textContent = "Population total (light green → dark green).";
    elLegendBar.style.background = "linear-gradient(90deg, #dcfce7, #14532d)";
    elLegMin.textContent = fmtInt(scale.min);
    elLegMax.textContent = fmtInt(scale.max);
    return;
  }

  if (activeLayerId === "pop_change"){
    elLegendDesc.textContent = "Population change (decrease = red, increase = green).";
    elLegendBar.style.background = "linear-gradient(90deg, #7f1d1d, #f8fafc, #166534)";
    elLegMin.textContent = fmtInt(scale.min);
    elLegMax.textContent = fmtInt(scale.max);
    return;
  }

  if (activeLayerId === "pop_change_pct"){
    elLegendDesc.textContent = "Population change % (decrease = red, increase = green).";
    elLegendBar.style.background = "linear-gradient(90deg, #7f1d1d, #f8fafc, #166534)";
    elLegMin.textContent = (scale.min*100).toFixed(1).replace(".",",") + "%";
    elLegMax.textContent = (scale.max*100).toFixed(1).replace(".",",") + "%";
    return;
  }

  if (activeLayerId === "turnout"){
    elLegendDesc.textContent = "Turnout = votes cast / registered voters (higher = greener).";
    elLegendBar.style.background = "linear-gradient(90deg, #eafff1, #0f7a3f)";
    elLegMin.textContent = (scale.min*100).toFixed(1).replace(".",",") + "%";
    elLegMax.textContent = (scale.max*100).toFixed(1).replace(".",",") + "%";
    return;
  }

  if (activeLayerId.includes("age_")){
    elLegendBar.style.background = "linear-gradient(90deg, #dcfce7, #14532d)";
    if (activeLayerId.endsWith("_pct")){
      elLegendDesc.textContent = "Age share (ratio of total population).";
      elLegMin.textContent = (scale.min*100).toFixed(1).replace(".",",") + "%";
      elLegMax.textContent = (scale.max*100).toFixed(1).replace(".",",") + "%";
    } else {
      elLegendDesc.textContent = "Age total (estimated using 2024 population − registered).";
      elLegMin.textContent = fmtInt(scale.min);
      elLegMax.textContent = fmtInt(scale.max);
    }
    return;
  }

  elLegendDesc.textContent = def ? def.label : "Legend";
  elLegendBar.style.background = "linear-gradient(90deg, #dcfce7, #14532d)";
  elLegMin.textContent = "—";
  elLegMax.textContent = "—";
}

/* ============================= STYLES ============================= */
function baseStyle(feature){
  const d = dataForFeature(feature);
  const def = LAYER_DEFS.find(x=>x.id===activeLayerId);

  let fill = "#eef2f7";
  let fillOpacity = 0.90;

  if (def?.kind === "election"){
    const e = d.elec;
    if (e?.winner){
      const base = partyColor(e.winner);

      // strong party color; close races lighten (but still vivid)
      const m = Number.isFinite(e.margin) ? clamp(e.margin, 0, 0.25) : 0.10;
      const mNorm = clamp(m / 0.25, 0, 1);
      const closeFactor = 1 - Math.pow(mNorm, 0.65);
      const mixAmt = 0.06 + 0.50 * closeFactor; // 0.06..0.56
      fill = mix(base, "#ffffff", mixAmt);
    } else {
      fillOpacity = 0.78;
    }
  } else {
    const v = valueForLayer(d);
    const scale = getScaleForActiveLayer();
    if (v === null || v === undefined || !Number.isFinite(v)){
      fill = "#eef2f7";
      fillOpacity = 0.78;
    } else {
      if (scale.kind === "seq"){
        const t = (v - scale.min) / (scale.max - scale.min || 1);
        fill = seqGreen(clamp(t,0,1));
      } else if (scale.kind === "div"){
        const t = (v / (scale.absMax || 1));
        fill = divRedWhiteGreen(t);
      } else if (scale.kind === "seq_turnout"){
        const t = (v - scale.min) / (scale.max - scale.min || 1);
        fill = mix("#eafff1", "#0f7a3f", clamp(t,0,1));
      }
    }
  }

  return {
    color: "#94a3b8",
    weight: 0.9,
    opacity: 0.95,
    fillColor: fill,
    fillOpacity,
    lineJoin: "round"
  };
}
function hoverStyle(){
  return { color: "#2563eb", weight: 2.2, opacity: 1, fillOpacity: 0.96 };
}
function selectedStyle(){
  return { color: "#0f172a", weight: 3.2, opacity: 1, fillOpacity: 0.97 };
}
function refreshStyles(){
  if (!geoLayer) return;
  geoLayer.setStyle(baseStyle);
  if (selectedLayer) selectedLayer.setStyle(selectedStyle());
  if (hoverLayer && hoverLayer !== selectedLayer) hoverLayer.setStyle(hoverStyle());
}

/* ============================= SELECTION ============================= */
function select(layer, feature){
  if (selectedLayer) geoLayer.resetStyle(selectedLayer);
  selectedLayer = layer;
  selectedLayer.setStyle(selectedStyle());
  elClear.style.display = "inline-flex";
  refreshInfoPanel(feature);
}
function unselect(){
  if (!selectedLayer) return;
  geoLayer.resetStyle(selectedLayer);
  selectedLayer = null;
  elClear.style.display = "none";
  refreshInfoPanel(null);
  refreshStyles();
}

/* ============================= INFO PANEL ============================= */
function refreshInfoPanel(featureOrNull){
  let feature = featureOrNull;
  if (selectedLayer?.feature) feature = selectedLayer.feature;

  if (!feature){
    elDName.textContent = "District";
    elDSub.textContent = "Hover or click a district.";
    elGrid.innerHTML = "";
    elBars.style.display = "none";
    elENote.style.display = "block";
    elENote.textContent = "Hover or click a district to see details.";
    return;
  }

  const d = dataForFeature(feature);
  const plate = d.plate;
  const provTr = plate ? provinceNameFromPlate(plate) : "Unknown";
  const distLabel = feature?.properties?.name || "—";

  elDName.textContent = distLabel;
  elDSub.innerHTML = `
    <span class="chip"><span class="sw" style="background:#60a5fa"></span>${provTr}</span>
    <span class="chip"><span class="sw" style="background:#34d399"></span>Plate ${plate ?? "—"}</span>
    ${selectedLayer ? `<span class="chip"><span class="sw" style="background:#0f172a"></span>Pinned</span>` : ""}
  `;

  const popY = d.pop ? d.pop[String(activeYear)] : null;
  const py = prevYear(activeYear);
  const popPrev = (d.pop && py) ? d.pop[String(py)] : null;
  const popChange = (Number.isFinite(popY) && Number.isFinite(popPrev)) ? (popY - popPrev) : null;
  const popChangePct = (Number.isFinite(popPrev) && popPrev !== 0 && Number.isFinite(popY)) ? ((popY - popPrev)/popPrev) : null;

  const pop2024 = d.pop ? d.pop["2024"] : null;
  const reg = d.elec?.registered ?? null;
  const cast = d.elec?.cast ?? null;
  const valid = d.elec?.valid ?? null;
  const turnout = (Number.isFinite(reg) && reg>0 && Number.isFinite(cast)) ? (cast/reg) : null;

  const u18 = (Number.isFinite(pop2024) && pop2024>0 && Number.isFinite(reg)) ? clamp(pop2024 - reg, 0, pop2024) : null;
  const u18pct = (Number.isFinite(u18) && Number.isFinite(pop2024) && pop2024>0) ? (u18/pop2024) : null;
  const p18 = (Number.isFinite(reg)) ? reg : null;
  const p18pct = (Number.isFinite(p18) && Number.isFinite(pop2024) && pop2024>0) ? (p18/pop2024) : null;

  const metrics = [
    { k:`Population (${activeYear})`, v: fmtInt(popY), s: py ? `vs ${py}: ${popChange===null?"—":(popChange>=0?"+":"") + fmtInt(popChange)}` : "No previous year" },
    { k:`Pop change %`, v: popChangePct===null ? "—" : ((popChangePct>=0?"+":"") + (popChangePct*100).toFixed(2).replace(".",",") + "%"), s: py ? `(${py}→${activeYear})` : "—" },
    { k:`Registered (18+)`, v: fmtInt(reg), s: "from province JSON" },
    { k:`Votes cast`, v: fmtInt(cast), s: "from province JSON" },
    { k:`Valid votes`, v: fmtInt(valid), s: "from province JSON" },
    { k:`Turnout`, v: turnout===null ? "—" : (turnout*100).toFixed(2).replace(".",",") + "%", s: "cast / registered" },
    { k:`0–18 total (est.)`, v: fmtInt(u18), s: "2024 pop − registered" },
    { k:`0–18 %`, v: u18pct===null ? "—" : (u18pct*100).toFixed(2).replace(".",",") + "%", s: "share of 2024 pop" },
    { k:`18+ total`, v: fmtInt(p18), s: "≈ registered" },
    { k:`18+ %`, v: p18pct===null ? "—" : (p18pct*100).toFixed(2).replace(".",",") + "%", s: "share of 2024 pop" },
  ];

  elGrid.innerHTML = metrics.map(m => `
    <div class="metric">
      <div class="k">${m.k}</div>
      <div class="v">${m.v}</div>
      <div class="s">${m.s}</div>
    </div>
  `).join("");

  const e = d.elec;
  if (!e || !e.votes || e.votes.size === 0 || !e.winner){
    elBars.style.display = "none";
    elENote.style.display = "block";
    elENote.textContent = "No election data for this district (missing province JSON or join mismatch).";
    return;
  }

  elBars.style.display = "flex";
  elENote.style.display = "block";

  const denom = Number.isFinite(e.denom) && e.denom>0 ? e.denom : (Number.isFinite(e.valid) && e.valid>0 ? e.valid : null);
  const sorted = [...e.votes.entries()].sort((a,b)=>b[1]-a[1]).slice(0,8);

  const winnerVotes = e.votes.get(e.winner) ?? null;
  const runnerVotes = e.runnerUp ? (e.votes.get(e.runnerUp) ?? null) : null;

  const wShare = (Number.isFinite(winnerVotes) && Number.isFinite(denom) && denom>0) ? (winnerVotes/denom) : null;
  const rShare = (Number.isFinite(runnerVotes) && Number.isFinite(denom) && denom>0) ? (runnerVotes/denom) : null;
  const margin = (Number.isFinite(wShare) && Number.isFinite(rShare)) ? (wShare - rShare) : null;

  const winnerLabel = cleanLabel(e.winner);
  const runnerLabel = e.runnerUp ? cleanLabel(e.runnerUp) : null;
  const marginTxt = (margin===null) ? "—" : (margin*100).toFixed(2).replace(".",",") + "%";
  const wShareTxt = (wShare===null) ? "—" : (wShare*100).toFixed(2).replace(".",",") + "%";

  elENote.innerHTML = `
    <span class="chip"><span class="sw" style="background:${partyColor(winnerLabel)}"></span>${winnerLabel}</span>
    ${runnerLabel ? `<span class="chip"><span class="sw" style="background:${partyColor(runnerLabel)}"></span>${runnerLabel}</span>` : ""}
    <span class="chip"><span class="sw" style="background:#0ea5e9"></span>Winner: ${wShareTxt}</span>
    <span class="chip"><span class="sw" style="background:#94a3b8"></span>Margin: ${marginTxt}</span>
  `;

  elBars.innerHTML = sorted.map(([p, v]) => {
    const pct = (Number.isFinite(denom) && denom>0) ? (v/denom) : null;
    const width = pct ? (pct*100) : 0;
    const col = partyColor(p);
    const pctTxt = pct ? (pct*100).toFixed(2).replace(".",",") + "%" : "—";
    return `
      <div class="bar-row">
        <div class="pname" title="${cleanLabel(p)}">
          <span class="swatch" style="background:${col}; box-shadow: 0 0 0 3px ${mix(col,"#ffffff",0.70)};"></span>
          ${cleanLabel(p)}
        </div>
        <div class="track"><div class="fill" style="width:${width.toFixed(2)}%; background:${col};"></div></div>
        <div class="val">${pctTxt} • ${fmtInt(v)}</div>
      </div>
    `;
  }).join("");
}

/* ============================= FINAL HOOKS ============================= */
refreshLegend();
</script>
</body>
</html>
