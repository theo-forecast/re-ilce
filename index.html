<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Turkey Redistricter</title>

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <style>
    :root{
      --bg: #f6f8fc;
      --panel: #ffffff;
      --panel2: #fbfcff;
      --text: #0f172a;
      --muted: #475569;
      --muted2:#64748b;
      --border:#e2e8f0;
      --shadow: 0 18px 55px rgba(15,23,42,.10);
      --shadow2: 0 10px 30px rgba(15,23,42,.08);
      --radius: 18px;
      --radius2: 14px;
      --accent:#2563eb;
      --accent2:#0ea5e9;
      --ok:#16a34a;
      --bad:#dc2626;
      --chip:#eef2ff;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:
        radial-gradient(1200px 700px at 12% 8%, rgba(37,99,235,.08), transparent 60%),
        radial-gradient(900px 600px at 85% 15%, rgba(14,165,233,.10), transparent 55%),
        radial-gradient(800px 600px at 70% 85%, rgba(22,163,74,.08), transparent 55%),
        var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      overflow:hidden;
    }

    .app{
      height:100%;
      display:grid;
      grid-template-columns: 1fr 360px;
      gap: 16px;
      padding: 16px;
    }

    .map-wrap{
      position:relative;
      border-radius: var(--radius);
      overflow:hidden;
      box-shadow: var(--shadow);
      background: #fff;
      border:1px solid rgba(226,232,240,.75);
    }

    #map{
      height:100%;
      width:100%;
    }

    /* Top bar */
    .topbar{
      position:absolute;
      z-index: 800;
      top: 14px;
      left: 14px;
      right: 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(226,232,240,.9);
      box-shadow: var(--shadow2);
      backdrop-filter: blur(8px);
    }
    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      min-width: 220px;
    }
    .dot{
      width:10px; height:10px; border-radius:999px;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      box-shadow: 0 0 0 4px rgba(37,99,235,.12);
    }
    .brand .title{
      font-weight: 800;
      letter-spacing:-0.02em;
      line-height:1.05;
    }
    .brand .subtitle{
      font-size:12px;
      color: var(--muted2);
      margin-top:2px;
    }
    .controls{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .control{
      display:flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid rgba(226,232,240,.95);
      background: rgba(248,250,252,.9);
    }
    .control label{
      font-size:12px;
      color: var(--muted);
      font-weight: 600;
      letter-spacing: .01em;
    }
    select{
      appearance:none;
      border:1px solid rgba(226,232,240,.0);
      background: transparent;
      font-weight:700;
      color: var(--text);
      padding: 4px 28px 4px 10px;
      border-radius: 999px;
      outline:none;
      cursor:pointer;
      background-image:
        linear-gradient(45deg, transparent 50%, #64748b 50%),
        linear-gradient(135deg, #64748b 50%, transparent 50%),
        linear-gradient(to right, transparent, transparent);
      background-position:
        calc(100% - 16px) 50%,
        calc(100% - 11px) 50%,
        0 0;
      background-size: 5px 5px, 5px 5px, 100% 100%;
      background-repeat:no-repeat;
    }
    .btn{
      border:none;
      cursor:pointer;
      font-weight:800;
      padding: 10px 14px;
      border-radius: 999px;
      background: var(--text);
      color:#fff;
      box-shadow: 0 10px 22px rgba(15,23,42,.14);
      transition: transform .12s ease, box-shadow .12s ease, opacity .12s ease;
      user-select:none;
    }
    .btn:hover{ transform: translateY(-1px); box-shadow: 0 14px 28px rgba(15,23,42,.16); }
    .btn:active{ transform: translateY(0px); opacity:.92; }

    .hint{
      font-size: 12px;
      color: var(--muted2);
      font-weight: 600;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(241,245,249,.85);
      border:1px solid rgba(226,232,240,.85);
      white-space:nowrap;
      max-width: 420px;
      overflow:hidden;
      text-overflow: ellipsis;
    }

    /* Right panel */
    .panel{
      height:100%;
      display:flex;
      flex-direction:column;
      gap: 14px;
      min-width: 320px;
    }

    .card{
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(226,232,240,.9);
      border-radius: var(--radius);
      box-shadow: var(--shadow2);
      padding: 14px;
      overflow:hidden;
    }
    .card h3{
      margin:0 0 10px 0;
      font-size: 14px;
      letter-spacing: -0.01em;
    }
    .muted{ color: var(--muted2); font-size: 12px; line-height:1.35; }

    .legendbar{
      height: 10px;
      border-radius: 999px;
      background: linear-gradient(90deg, #dcfce7, #166534);
      border: 1px solid rgba(15,23,42,.10);
      margin: 10px 0 8px;
    }
    .legendlabels{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size:12px;
      color: var(--muted);
      font-weight:700;
    }

    .district-header{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }
    .district-name{
      font-size: 16px;
      font-weight: 900;
      letter-spacing: -0.02em;
      line-height:1.1;
      margin:0;
    }
    .district-sub{
      margin-top: 3px;
      font-size:12px;
      color: var(--muted);
      font-weight:700;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding: 4px 10px;
      background: var(--chip);
      border: 1px solid rgba(99,102,241,.18);
      color: #3730a3;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 800;
    }
    .chip .sw{ width:10px; height:10px; border-radius: 3px; background:#94a3b8; }

    .clear-btn{
      border:none;
      cursor:pointer;
      font-weight:900;
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(241,245,249,.95);
      border: 1px solid rgba(226,232,240,.95);
      color: var(--text);
      transition: transform .12s ease, background .12s ease;
      white-space:nowrap;
    }
    .clear-btn:hover{ transform: translateY(-1px); background: rgba(226,232,240,.85); }
    .clear-btn:active{ transform: translateY(0px); opacity:.92; }

    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top: 12px;
    }
    .metric{
      padding: 10px 10px;
      border-radius: var(--radius2);
      background: rgba(248,250,252,.92);
      border: 1px solid rgba(226,232,240,.92);
    }
    .metric .k{
      font-size: 11px;
      color: var(--muted2);
      font-weight: 800;
      letter-spacing: .02em;
      text-transform: uppercase;
    }
    .metric .v{
      margin-top: 5px;
      font-size: 14px;
      font-weight: 900;
      letter-spacing: -0.01em;
    }
    .metric .s{
      margin-top: 2px;
      font-size: 12px;
      color: var(--muted);
      font-weight: 700;
    }

    .section-title{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-top: 10px;
      padding-top: 12px;
      border-top: 1px solid rgba(226,232,240,.95);
    }
    .section-title h4{
      margin:0;
      font-size: 13px;
      font-weight: 900;
      letter-spacing: -0.01em;
    }
    .section-title .small{
      font-size: 12px;
      color: var(--muted2);
      font-weight: 800;
      white-space:nowrap;
    }

    .bars{
      margin-top: 10px;
      display:flex;
      flex-direction:column;
      gap: 8px;
    }
    .bar-row{
      display:grid;
      grid-template-columns: 120px 1fr 150px;
      gap:10px;
      align-items:center;
    }
    .bar-row .pname{
      display:flex;
      align-items:center;
      gap:8px;
      font-weight: 900;
      font-size: 12px;
      color: var(--text);
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .swatch{
      width:10px; height:10px; border-radius: 3px;
      background:#94a3b8;
      box-shadow: 0 0 0 3px rgba(148,163,184,.20);
      flex:0 0 auto;
    }
    .track{
      height: 10px;
      border-radius: 999px;
      background: rgba(226,232,240,.9);
      border: 1px solid rgba(148,163,184,.18);
      overflow:hidden;
    }
    .fill{
      height:100%;
      border-radius: 999px;
      width: 0%;
      background: #64748b;
      transition: width .18s ease;
    }
    .bar-row .val{
      font-variant-numeric: tabular-nums;
      text-align:right;
      font-size: 12px;
      color: var(--muted);
      font-weight: 800;
      white-space:nowrap;
    }

    /* Leaflet tweaks */
    .leaflet-control-zoom{
      border-radius: 14px !important;
      overflow:hidden;
      box-shadow: var(--shadow2);
      border: 1px solid rgba(226,232,240,.95);
    }
    .leaflet-bar a{
      background: rgba(255,255,255,.95) !important;
      color: var(--text) !important;
    }
    .leaflet-container{
      background: #ffffff;
      outline:none;
      font: inherit;
    }

    .district-tooltip{
      background: rgba(255,255,255,.95);
      border: 1px solid rgba(226,232,240,.95);
      color: var(--text);
      border-radius: 12px;
      box-shadow: var(--shadow2);
      padding: 8px 10px;
      font-weight: 900;
      letter-spacing: -0.01em;
    }
    .district-tooltip .t2{
      display:block;
      margin-top:2px;
      font-size: 12px;
      color: var(--muted);
      font-weight: 800;
    }
  </style>
</head>

<body>
  <div class="app">
    <div class="map-wrap">
      <div class="topbar">
        <div class="brand">
          <div class="dot"></div>
          <div>
            <div class="title">Turkey Redistricter</div>
            <div class="subtitle">all districts • elections • population • turnout • age</div>
          </div>
        </div>

        <div class="controls">
          <div class="control">
            <label for="layerSel">Layer</label>
            <select id="layerSel"></select>
          </div>
          <div class="control">
            <label for="yearSel">Year</label>
            <select id="yearSel">
              <option value="2024" selected>2024</option>
              <option value="2019">2019</option>
              <option value="2014">2014</option>
            </select>
          </div>
          <button class="btn" id="fitBtn" title="Fit Turkey">Fit</button>
          <div class="hint" id="hintText" title="Tip">
            Hover to preview. Click to pin/unpin. (Turnout & age use 2024 pop + 2024 registered.)
          </div>
        </div>
      </div>

      <div id="map"></div>
    </div>

    <div class="panel">
      <div class="card" id="legendCard">
        <h3>Legend</h3>
        <div class="muted" id="legendDesc">Population total (light green → dark green).</div>
        <div class="legendbar" id="legendBar"></div>
        <div class="legendlabels"><span id="legMin">—</span><span id="legMax">—</span></div>
      </div>

      <div class="card" id="districtCard">
        <div class="district-header">
          <div>
            <p class="district-name" id="dName">District</p>
            <div class="district-sub" id="dSub">Hover or click a district.</div>
          </div>
          <button class="clear-btn" id="clearBtn" style="display:none;">Clear</button>
        </div>

        <div class="grid" id="metricsGrid">
          <!-- filled by JS -->
        </div>

        <div class="section-title">
          <h4>Election (winner)</h4>
          <div class="small" id="eSmall">Winner shading = lighter when margin is small</div>
        </div>
        <div class="muted" id="eNote" style="margin-top:6px;">No election data for this district (missing province JSON or join mismatch).</div>
        <div class="bars" id="bars" style="display:none;"></div>
      </div>
    </div>
  </div>

<script>
/**
 * NOTE: fetch() won’t work if you open this as file://
 * Use GitHub Pages (https://...) or any local server.
 */

/* ------------------------------- Files ---------------------------------- */
const FILE_GEOJSON = "turkey-admin-level-6.geojson";
const FILE_POP_CSV = "province_district_2014_2019_2024.csv";

/* ---------------------------- Province mapping --------------------------- */
/* Plate -> official name (Turkish). Filenames are derived by TR-folding + TitleCase. */
const PLATE_TO_PROVINCE_TR = {
  1:"Adana",2:"Adıyaman",3:"Afyonkarahisar",4:"Ağrı",5:"Amasya",6:"Ankara",7:"Antalya",8:"Artvin",9:"Aydın",10:"Balıkesir",
  11:"Bilecik",12:"Bingöl",13:"Bitlis",14:"Bolu",15:"Burdur",16:"Bursa",17:"Çanakkale",18:"Çankırı",19:"Çorum",20:"Denizli",
  21:"Diyarbakır",22:"Edirne",23:"Elazığ",24:"Erzincan",25:"Erzurum",26:"Eskişehir",27:"Gaziantep",28:"Giresun",29:"Gümüşhane",30:"Hakkâri",
  31:"Hatay",32:"Isparta",33:"Mersin",34:"İstanbul",35:"İzmir",36:"Kars",37:"Kastamonu",38:"Kayseri",39:"Kırklareli",40:"Kırşehir",
  41:"Kocaeli",42:"Konya",43:"Kütahya",44:"Malatya",45:"Manisa",46:"Kahramanmaraş",47:"Mardin",48:"Muğla",49:"Muş",50:"Nevşehir",
  51:"Niğde",52:"Ordu",53:"Rize",54:"Sakarya",55:"Samsun",56:"Siirt",57:"Sinop",58:"Sivas",59:"Tekirdağ",60:"Tokat",
  61:"Trabzon",62:"Tunceli",63:"Şanlıurfa",64:"Uşak",65:"Van",66:"Yozgat",67:"Zonguldak",68:"Aksaray",69:"Bayburt",70:"Karaman",
  71:"Kırıkkale",72:"Batman",73:"Şırnak",74:"Bartın",75:"Ardahan",76:"Iğdır",77:"Yalova",78:"Karabük",79:"Kilis",80:"Osmaniye",81:"Düzce"
};
const PROVINCE_FILES = Object.entries(PLATE_TO_PROVINCE_TR).map(([plate, tr]) => ({
  plate: Number(plate),
  trName: tr,
  file: provinceFileName(tr) + ".json"
}));

/* ---------------------------- Text normalization ------------------------- */
const TR_CHARMAP = {
  "İ":"I","I":"I","ı":"i",
  "Ş":"S","ş":"s",
  "Ğ":"G","ğ":"g",
  "Ü":"U","ü":"u",
  "Ö":"O","ö":"o",
  "Ç":"C","ç":"c",
  "Â":"A","â":"a","Î":"I","î":"i","Û":"U","û":"u"
};

function foldTR(str){
  const s = (str ?? "").toString().replace(/[İIıŞşĞğÜüÖöÇçÂâÎîÛû]/g, ch => TR_CHARMAP[ch] || ch);
  // remove remaining diacritics
  return s.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

function keyify(str){
  return foldTR(str)
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, " ")
    .trim()
    .replace(/\s+/g, "-");
}

function cleanLabel(str){
  return (str ?? "").toString().replace(/\s+/g, " ").trim();
}

function provinceFileName(trName){
  // "Şanlıurfa" -> "Sanliurfa"
  const folded = foldTR(trName).toLowerCase().replace(/[^a-z0-9]/g,"");
  return folded ? (folded[0].toUpperCase() + folded.slice(1)) : "Province";
}

/* ------------------------------ Number parsing --------------------------- */
function parseTrNumber(x){
  if (x === null || x === undefined) return null;
  let s = String(x).trim();
  if (!s) return null;

  // remove non-number except separators and signs
  s = s.replace(/\s+/g,"").replace(/%/g,"");

  // If both '.' and ',' exist, assume '.' thousands and ',' decimal -> normalize
  if (s.includes(".") && s.includes(",")) {
    s = s.replace(/\./g,"").replace(/,/g,".");
  } else if (s.includes(".")) {
    const parts = s.split(".");
    if (parts.length > 2) {
      s = parts.join("");
    } else if (parts.length === 2) {
      // if exactly 3 digits after dot => thousands
      if (parts[1].length === 3) s = parts.join("");
      // else decimal: keep
    }
  } else if (s.includes(",")) {
    const parts = s.split(",");
    if (parts.length === 2 && parts[1].length !== 3) {
      s = parts.join(".");
    } else {
      s = parts.join("");
    }
  }

  s = s.replace(/[^0-9.\-]/g,"");
  const n = Number(s);
  return Number.isFinite(n) ? n : null;
}

function fmtInt(n){
  if (!Number.isFinite(n)) return "—";
  return Math.round(n).toLocaleString("tr-TR");
}
function fmtPct(x){
  if (!Number.isFinite(x)) return "—";
  return (x*100).toFixed(2).replace(".", ",") + "%";
}
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

/* ------------------------------ Color helpers ---------------------------- */
function hexToRgb(hex){
  const h = hex.replace("#","").trim();
  const full = (h.length===3) ? h.split("").map(c=>c+c).join("") : h;
  const n = parseInt(full,16);
  return {r:(n>>16)&255, g:(n>>8)&255, b:n&255};
}
function rgbToHex({r,g,b}){
  const to = v => v.toString(16).padStart(2,"0");
  return "#" + to(r) + to(g) + to(b);
}
function mix(hexA, hexB, t){
  const a=hexToRgb(hexA), b=hexToRgb(hexB);
  return rgbToHex({
    r: Math.round(a.r + (b.r-a.r)*t),
    g: Math.round(a.g + (b.g-a.g)*t),
    b: Math.round(a.b + (b.b-a.b)*t),
  });
}
function seqGreen(t){
  // light green -> deep green
  return mix("#dcfce7", "#166534", clamp(t,0,1));
}
function divRedWhiteGreen(t){
  // t in [-1,1]
  const x = clamp(t,-1,1);
  if (x < 0) return mix("#b91c1c", "#f8fafc", (x+1));
  return mix("#f8fafc", "#15803d", x);
}

/* ------------------------------ Party colors ----------------------------- */
const PARTY_COLORS = new Map([
  ["chp", "#e11d48"],
  ["ak-parti", "#f59e0b"],
  ["mhp", "#b91c1c"],
  ["iyi-parti", "#2563eb"],
  ["dem-parti", "#7c3aed"],
  ["yesil-sol-parti", "#16a34a"],
  ["hdp", "#7c3aed"],
  ["tip", "#6d28d9"],
  ["zafer-partisi", "#0f172a"],
  ["yeniden-refah", "#16a34a"],
  ["saadet", "#0ea5e9"],
  ["deva", "#3b82f6"],
  ["gelecek", "#22c55e"],
  ["bbp", "#ef4444"],
  ["memleket", "#f97316"],
  ["vatan-partisi", "#a16207"],
  ["tkp", "#dc2626"],
  ["sol-parti", "#ef4444"],
  ["hkp", "#8b5cf6"],
  ["gencleri", "#64748b"], // fallback-ish
  ["gençparti", "#64748b"],
  ["gencparti", "#64748b"],
  ["millet", "#64748b"],
  ["milli-yol", "#64748b"],
  ["hak-par", "#64748b"],
  ["anap", "#64748b"],
  ["yp", "#64748b"],
  ["ap", "#64748b"],
  ["ab", "#64748b"],
  ["gbp", "#64748b"]
]);

function partyColor(name){
  const k = keyify(name);
  return PARTY_COLORS.get(k) || "#64748b";
}

/* ------------------------------ Layer config ----------------------------- */
const LAYER_DEFS = [
  { id:"election_winner", label:"Election: winner (margin shading)", kind:"election" },

  { id:"pop_total", label:"Population: total", kind:"seq" },
  { id:"pop_change", label:"Population: change (abs)", kind:"div" },
  { id:"pop_change_pct", label:"Population: change (%)", kind:"div" },

  { id:"turnout", label:"Turnout (% cast / registered)", kind:"seq_turnout" },

  { id:"age_u18_pct", label:"Age: 0–18 (%)", kind:"seq" },
  { id:"age_u18_total", label:"Age: 0–18 (total)", kind:"seq" },
  { id:"age_18p_pct", label:"Age: 18+ (%)", kind:"seq" },
  { id:"age_18p_total", label:"Age: 18+ (total)", kind:"seq" },
];

/* ----------------------------- State containers -------------------------- */
let map, base, geoLayer;
let turkeyBounds = null;

let activeLayerId = "election_winner";
let activeYear = 2024;

let hoverLayer = null;
let selectedLayer = null;

const popByKey = new Map();      // key => {2014,2019,2024, provinceTr, districtLabel}
const electionByKey = new Map(); // key => {registered, cast, valid, votes:Map, winner, runnerUp, margin, ...}

const featureByKey = new Map();  // key => layer

/* ------------------------------- UI refs --------------------------------- */
const elLayer = document.getElementById("layerSel");
const elYear  = document.getElementById("yearSel");
const elFit   = document.getElementById("fitBtn");
const elHint  = document.getElementById("hintText");

const elLegendDesc = document.getElementById("legendDesc");
const elLegendBar  = document.getElementById("legendBar");
const elLegMin     = document.getElementById("legMin");
const elLegMax     = document.getElementById("legMax");

const elDName = document.getElementById("dName");
const elDSub  = document.getElementById("dSub");
const elGrid  = document.getElementById("metricsGrid");
const elBars  = document.getElementById("bars");
const elENote = document.getElementById("eNote");
const elClear = document.getElementById("clearBtn");

/* ------------------------------- Init UI --------------------------------- */
for (const def of LAYER_DEFS){
  const opt = document.createElement("option");
  opt.value = def.id;
  opt.textContent = def.label;
  if (def.id === activeLayerId) opt.selected = true;
  elLayer.appendChild(opt);
}

elLayer.addEventListener("change", () => {
  activeLayerId = elLayer.value;
  refreshStyles();
  refreshLegend();
  refreshInfoPanel();
});

elYear.addEventListener("change", () => {
  activeYear = Number(elYear.value);
  refreshStyles();
  refreshLegend();
  refreshInfoPanel();
});

elFit.addEventListener("click", () => {
  if (turkeyBounds) map.fitBounds(turkeyBounds, { padding:[18,18] });
});

elClear.addEventListener("click", () => {
  if (selectedLayer){
    unselect();
  }
});

/* ------------------------------ Leaflet init ----------------------------- */
map = L.map("map", {
  zoomControl: true,
  preferCanvas: true
});

base = L.tileLayer(
  "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png",
  { attribution: '&copy; OpenStreetMap &copy; CARTO', maxZoom: 18 }
).addTo(map);

map.setView([39.0, 35.0], 6);

/* ------------------------------ Loading pipeline -------------------------- */
(async function boot(){
  await Promise.all([
    loadPopulationCsv(),
    loadElectionAllProvinces()
  ]);
  await loadGeoJsonAndDraw();
  refreshLegend();
  refreshInfoPanel();
})().catch(err => {
  console.error(err);
  elHint.textContent = "Load error. Check console + file names.";
});

/* ------------------------------- Loaders --------------------------------- */
async function loadPopulationCsv(){
  const res = await fetch(FILE_POP_CSV);
  if (!res.ok) throw new Error("Population CSV fetch failed: " + res.status);
  const txt = await res.text();
  const lines = txt.trim().split(/\r?\n/);
  if (lines.length < 2) return;

  const header = lines[0].split(",").map(h=>h.trim());
  const idx = {
    province: header.indexOf("Province"),
    district: header.indexOf("District"),
    y2014: header.indexOf("2014"),
    y2019: header.indexOf("2019"),
    y2024: header.indexOf("2024")
  };

  // build province-name -> plate by folding Turkish names + common ascii
  const provinceToPlate = new Map();
  for (const [plateStr, trName] of Object.entries(PLATE_TO_PROVINCE_TR)){
    const plate = Number(plateStr);
    provinceToPlate.set(keyify(trName), plate);
    provinceToPlate.set(keyify(foldTR(trName)), plate);
    // also store derived filename stem (often matches csv)
    provinceToPlate.set(keyify(provinceFileName(trName)), plate);
  }
  // add special common spellings
  provinceToPlate.set(keyify("Sanliurfa"), 63);
  provinceToPlate.set(keyify("Kahramanmaras"), 46);
  provinceToPlate.set(keyify("Igdir"), 76);
  provinceToPlate.set(keyify("Kirikkale"), 71);
  provinceToPlate.set(keyify("Kirsehir"), 40);
  provinceToPlate.set(keyify("Kastamonu"), 37);

  for (let i=1;i<lines.length;i++){
    const row = lines[i].split(",");
    const prov = row[idx.province]?.trim();
    const dist = row[idx.district]?.trim();
    if (!prov || !dist) continue;

    const plate = provinceToPlate.get(keyify(prov));
    if (!plate) continue;

    const key = plate + ":" + keyify(dist);
    const y2014 = Number(row[idx.y2014]);
    const y2019 = Number(row[idx.y2019]);
    const y2024 = Number(row[idx.y2024]);

    popByKey.set(key, {
      province: prov,
      district: dist,
      2014: Number.isFinite(y2014) ? y2014 : null,
      2019: Number.isFinite(y2019) ? y2019 : null,
      2024: Number.isFinite(y2024) ? y2024 : null
    });
  }
}

async function loadElectionAllProvinces(){
  // Try loading Province.json for all 81 provinces; ignore missing ones.
  // This is the only way on GitHub Pages (no directory listing).
  const tasks = PROVINCE_FILES.map(async p => {
    try{
      const res = await fetch(p.file, { cache:"no-store" });
      if (!res.ok) return null;
      const json = await res.json();
      parseProvinceElectionJson(p.plate, json);
      return p.plate;
    }catch(e){
      return null;
    }
  });
  await Promise.all(tasks);
}

function getField(row, names){
  for (const n of names){
    if (row && Object.prototype.hasOwnProperty.call(row, n)) return row[n];
  }
  return undefined;
}

function parseProvinceElectionJson(plate, json){
  // json is an array of objects
  if (!Array.isArray(json)) return;

  for (const row of json){
    const ilceId = getField(row, ["Ilce Id","İlçe Id","IlceId","İlçeId","İlce Id ","İlçe Id "]);
    const ilceAdi = getField(row, ["Ilce Adi","İlçe Adı","Ilce Adı","İlçe Adi","IlceAdi","İlçeAdı","İlçe Adi","Ilce Adi "]);

    const idStr = cleanLabel(ilceId);
    const nameStr = cleanLabel(ilceAdi);

    if (!nameStr) continue;
    if (!idStr || keyify(idStr) === "oy-orani") continue; // skip percent rows
    if (!/^\d+$/.test(foldTR(idStr).replace(/\D/g,"")) && idStr.length > 0) {
      // Some files use non-numeric for percent/meta. If it isn’t numeric, skip.
      if (!/^\d+$/.test(idStr.trim())) continue;
    }

    // core fields (registered/cast/valid)
    const registered = parseTrNumber(getField(row, ["Kayitli Secmen Sayisi","Kayıtlı Seçmen Sayısı","KayitliSecmenSayisi","KayıtlıSeçmenSayısı"]));
    const cast      = parseTrNumber(getField(row, ["Oy Kullanan Secmen Sayisi","Oy Kullanan Seçmen Sayısı","OyKullananSecmenSayisi"]));
    const valid     = parseTrNumber(getField(row, ["Gecerli Oy Toplami","Geçerli Oy Toplamı","GecerliOyToplami"]));

    const votes = new Map();
    const skipKeys = new Set([
      "Ilce Id","İlçe Id","Ilce Adi","İlçe Adı","Ilce Adı","İlçe Adi","Belde Adi","Belde Adı",
      "Kayitli Secmen Sayisi","Kayıtlı Seçmen Sayısı",
      "Oy Kullanan Secmen Sayisi","Oy Kullanan Seçmen Sayısı",
      "Gecerli Oy Toplami","Geçerli Oy Toplamı"
    ]);

    // collect vote-like fields: anything numeric-ish that isn’t one of the metadata fields
    for (const [k,v] of Object.entries(row)){
      if (skipKeys.has(k)) continue;
      const kk = cleanLabel(k);
      if (!kk) continue;

      // also skip obvious empty header row fields
      if (keyify(kk) === "oy-orani") continue;

      const n = parseTrNumber(v);
      if (!Number.isFinite(n) || n <= 0) continue;

      votes.set(kk, n);
    }

    // Determine winner & margin using vote totals (not percent rows)
    const sorted = [...votes.entries()].sort((a,b)=>b[1]-a[1]);
    const winner = sorted[0]?.[0] ?? null;
    const winnerVotes = sorted[0]?.[1] ?? null;
    const runnerUp = sorted[1]?.[0] ?? null;
    const runnerUpVotes = sorted[1]?.[1] ?? null;

    const denom = Number.isFinite(valid) && valid>0 ? valid : (sorted.reduce((s,[_p,val])=>s+val,0) || null);
    const margin = (Number.isFinite(winnerVotes) && Number.isFinite(runnerUpVotes) && Number.isFinite(denom) && denom>0)
      ? (winnerVotes-runnerUpVotes)/denom
      : null;

    const districtKey = keyify(nameStr);
    const key = plate + ":" + districtKey;

    electionByKey.set(key, {
      plate,
      districtNameRaw: nameStr,
      registered: Number.isFinite(registered) ? registered : null,
      cast: Number.isFinite(cast) ? cast : null,
      valid: Number.isFinite(valid) ? valid : null,
      denom: Number.isFinite(denom) ? denom : null,
      votes,
      winner,
      runnerUp,
      margin
    });
  }
}

async function loadGeoJsonAndDraw(){
  const res = await fetch(FILE_GEOJSON);
  if (!res.ok) throw new Error("GeoJSON fetch failed: " + res.status);
  const gj = await res.json();

  geoLayer = L.geoJSON(gj, {
    // Remove the “map tacks”: your GeoJSON has Point features; we only want polygons.
    filter: (feature) => {
      const t = feature?.geometry?.type;
      return t === "Polygon" || t === "MultiPolygon";
    },
    style: baseStyle,
    onEachFeature: (feature, layer) => {
      const key = featureKey(feature);
      featureByKey.set(key, layer);

      const title = displayDistrictTitle(feature);
      layer.bindTooltip(title, { sticky:true, className:"district-tooltip" });

      layer.on("mouseover", () => {
        hoverLayer = layer;
        if (hoverLayer !== selectedLayer){
          hoverLayer.setStyle(hoverStyle());
        }
        // side panel shows hover ONLY if nothing is pinned
        if (!selectedLayer) refreshInfoPanel(feature);
      });

      layer.on("mouseout", () => {
        if (hoverLayer && hoverLayer !== selectedLayer){
          geoLayer.resetStyle(hoverLayer);
        }
        hoverLayer = null;
        if (!selectedLayer) refreshInfoPanel(null);
      });

      layer.on("click", () => {
        if (selectedLayer === layer){
          unselect();
          return;
        }
        select(layer, feature);
      });
    }
  }).addTo(map);

  turkeyBounds = geoLayer.getBounds();
  map.fitBounds(turkeyBounds, { padding:[18,18] });
}

/* ------------------------------ Keys / display --------------------------- */
function featurePlate(feature){
  const net = feature?.properties?.network || "";
  const m = String(net).match(/TR(\d+)/i);
  return m ? Number(m[1]) : null;
}
function featureKey(feature){
  const plate = featurePlate(feature);
  const dist = feature?.properties?.name || "";
  return (plate ?? "null") + ":" + keyify(dist);
}
function provinceNameFromPlate(plate){
  return PLATE_TO_PROVINCE_TR[plate] || ("Plate " + plate);
}

function displayDistrictTitle(feature){
  const plate = featurePlate(feature);
  const prov = plate ? provinceNameFromPlate(plate) : "Unknown";
  const dist = feature?.properties?.name || "—";
  return `<span>${dist}</span><span class="t2">${prov} • ${plate ?? "—"}</span>`;
}

/* ------------------------------ Layer values ----------------------------- */
function prevYear(y){
  if (y === 2024) return 2019;
  if (y === 2019) return 2014;
  return null;
}

function dataForFeature(feature){
  const key = featureKey(feature);
  const pop = popByKey.get(key) || null;
  const elec = electionByKey.get(key) || null;
  const plate = featurePlate(feature);
  return { key, plate, pop, elec, feature };
}

function valueForLayer(d){
  const def = LAYER_DEFS.find(x=>x.id===activeLayerId);
  if (!def) return null;

  if (def.kind === "election"){
    // election is categorical
    return null;
  }

  // population
  if (activeLayerId === "pop_total"){
    return d.pop ? d.pop[String(activeYear)] : null;
  }
  if (activeLayerId === "pop_change"){
    const py = prevYear(activeYear);
    if (!d.pop || !py) return null;
    const a = d.pop[String(activeYear)];
    const b = d.pop[String(py)];
    if (!Number.isFinite(a) || !Number.isFinite(b)) return null;
    return a - b;
  }
  if (activeLayerId === "pop_change_pct"){
    const py = prevYear(activeYear);
    if (!d.pop || !py) return null;
    const a = d.pop[String(activeYear)];
    const b = d.pop[String(py)];
    if (!Number.isFinite(a) || !Number.isFinite(b) || b === 0) return null;
    return (a - b) / b; // ratio
  }

  // turnout & age use election registered/cast and 2024 pop
  if (activeLayerId === "turnout"){
    const reg = d.elec?.registered;
    const cast = d.elec?.cast;
    if (!Number.isFinite(reg) || !Number.isFinite(cast) || reg <= 0) return null;
    return cast / reg; // ratio
  }

  const pop2024 = d.pop ? d.pop["2024"] : null;
  const reg = d.elec?.registered;

  if (!Number.isFinite(pop2024) || pop2024 <= 0 || !Number.isFinite(reg) || reg < 0) return null;

  const u18 = clamp(pop2024 - reg, 0, pop2024);
  const p18 = clamp(reg, 0, pop2024);

  if (activeLayerId === "age_u18_pct") return u18 / pop2024;
  if (activeLayerId === "age_u18_total") return u18;
  if (activeLayerId === "age_18p_pct") return p18 / pop2024;
  if (activeLayerId === "age_18p_total") return p18;

  return null;
}

/* ------------------------------ Style logic ------------------------------ */
function baseStyle(feature){
  const d = dataForFeature(feature);
  const def = LAYER_DEFS.find(x=>x.id===activeLayerId);

  let fill = "#f1f5f9"; // default light gray
  let fillOpacity = 0.90;

  if (def?.kind === "election"){
    const e = d.elec;
    if (e?.winner && Number.isFinite(e?.margin)){
      const base = partyColor(e.winner);
      const m = clamp(e.margin, 0, 0.25); // cap at 25% for shading scale
      const t = clamp(1 - (m / 0.25), 0, 1); // close -> 1
      // lighter when margin is small
      fill = mix(base, "#ffffff", 0.20 + 0.65*t);
    } else if (e?.winner){
      fill = mix(partyColor(e.winner), "#ffffff", 0.35);
    } else {
      fill = "#eef2f7";
      fillOpacity = 0.75;
    }
  } else {
    const v = valueForLayer(d);
    const scale = getScaleForActiveLayer();
    if (v === null || v === undefined || !Number.isFinite(v)){
      fill = "#eef2f7";
      fillOpacity = 0.78;
    } else {
      if (scale.kind === "seq"){
        const t = (v - scale.min) / (scale.max - scale.min || 1);
        fill = seqGreen(clamp(t,0,1));
      } else if (scale.kind === "div"){
        const t = (v / (scale.absMax || 1));
        fill = divRedWhiteGreen(t);
      } else if (scale.kind === "seq_turnout"){
        // turnout: greener as higher, but keep contrast
        const t = (v - scale.min) / (scale.max - scale.min || 1);
        fill = mix("#eafff1", "#0f7a3f", clamp(t,0,1));
      }
    }
  }

  return {
    color: "#94a3b8",
    weight: 0.9,
    opacity: 0.95,
    fillColor: fill,
    fillOpacity,
    lineJoin: "round"
  };
}

function hoverStyle(){
  return {
    color: "#2563eb",
    weight: 2.2,
    opacity: 1,
    fillOpacity: 0.96
  };
}

function selectedStyle(){
  return {
    color: "#0f172a",
    weight: 3.2,
    opacity: 1,
    fillOpacity: 0.97
  };
}

function refreshStyles(){
  if (!geoLayer) return;
  geoLayer.setStyle(baseStyle);

  if (selectedLayer){
    selectedLayer.setStyle(selectedStyle());
  }
  if (hoverLayer && hoverLayer !== selectedLayer){
    hoverLayer.setStyle(hoverStyle());
  }
}

/* ------------------------------ Selection logic -------------------------- */
function select(layer, feature){
  if (selectedLayer){
    geoLayer.resetStyle(selectedLayer);
  }
  selectedLayer = layer;
  selectedLayer.setStyle(selectedStyle());
  elClear.style.display = "inline-flex";
  refreshInfoPanel(feature);
}

function unselect(){
  if (!selectedLayer) return;
  geoLayer.resetStyle(selectedLayer);
  selectedLayer = null;
  elClear.style.display = "none";
  refreshInfoPanel(null);
  refreshStyles();
}

/* ------------------------------ Scales/Legend ---------------------------- */
let cachedScaleKey = null;
let cachedScale = null;

function getScaleForActiveLayer(){
  const k = activeLayerId + ":" + activeYear;
  if (k === cachedScaleKey && cachedScale) return cachedScale;

  const def = LAYER_DEFS.find(x=>x.id===activeLayerId);
  if (!def || def.kind === "election"){
    cachedScaleKey = k;
    cachedScale = { kind:"none", min:0, max:1, absMax:1 };
    return cachedScale;
  }

  const values = [];
  geoLayer?.eachLayer(l => {
    const f = l.feature;
    const d = dataForFeature(f);
    const v = valueForLayer(d);
    if (Number.isFinite(v)) values.push(v);
  });

  let scale;
  if (!values.length){
    scale = { kind: (activeLayerId==="turnout" ? "seq_turnout" : "seq"), min:0, max:1, absMax:1 };
  } else if (activeLayerId === "pop_change" || activeLayerId === "pop_change_pct"){
    const absMax = Math.max(...values.map(v => Math.abs(v))) || 1;
    scale = { kind:"div", absMax, min: -absMax, max: absMax };
  } else if (activeLayerId === "turnout"){
    const min = Math.min(...values);
    const max = Math.max(...values);
    scale = { kind:"seq_turnout", min, max, absMax:1 };
  } else {
    const min = Math.min(...values);
    const max = Math.max(...values);
    scale = { kind:"seq", min, max, absMax:1 };
  }

  cachedScaleKey = k;
  cachedScale = scale;
  return scale;
}

function refreshLegend(){
  const def = LAYER_DEFS.find(x=>x.id===activeLayerId);
  const scale = getScaleForActiveLayer();

  if (def?.kind === "election"){
    elLegendDesc.textContent = "Winner color (party). Lighter shade = smaller winning margin.";
    elLegendBar.style.background = "linear-gradient(90deg, #ffffff, #e2e8f0)";
    elLegMin.textContent = "Close";
    elLegMax.textContent = "Landslide";
    return;
  }

  if (activeLayerId === "pop_total"){
    elLegendDesc.textContent = "Population total (light green → dark green).";
    elLegendBar.style.background = "linear-gradient(90deg, #dcfce7, #166534)";
    elLegMin.textContent = fmtInt(scale.min);
    elLegMax.textContent = fmtInt(scale.max);
    return;
  }

  if (activeLayerId === "pop_change"){
    elLegendDesc.textContent = "Population change (decrease = red, increase = green).";
    elLegendBar.style.background = "linear-gradient(90deg, #b91c1c, #f8fafc, #15803d)";
    elLegMin.textContent = fmtInt(scale.min);
    elLegMax.textContent = fmtInt(scale.max);
    return;
  }

  if (activeLayerId === "pop_change_pct"){
    elLegendDesc.textContent = "Population change % (decrease = red, increase = green).";
    elLegendBar.style.background = "linear-gradient(90deg, #b91c1c, #f8fafc, #15803d)";
    elLegMin.textContent = (scale.min*100).toFixed(1).replace(".",",") + "%";
    elLegMax.textContent = (scale.max*100).toFixed(1).replace(".",",") + "%";
    return;
  }

  if (activeLayerId === "turnout"){
    elLegendDesc.textContent = "Turnout = votes cast / registered voters (higher = greener).";
    elLegendBar.style.background = "linear-gradient(90deg, #eafff1, #0f7a3f)";
    elLegMin.textContent = (scale.min*100).toFixed(1).replace(".",",") + "%";
    elLegMax.textContent = (scale.max*100).toFixed(1).replace(".",",") + "%";
    return;
  }

  // Age layers
  if (activeLayerId.includes("age_")){
    if (activeLayerId.endsWith("_pct")){
      elLegendDesc.textContent = "Age share (ratio of total population).";
      elLegendBar.style.background = "linear-gradient(90deg, #dcfce7, #166534)";
      elLegMin.textContent = (scale.min*100).toFixed(1).replace(".",",") + "%";
      elLegMax.textContent = (scale.max*100).toFixed(1).replace(".",",") + "%";
    } else {
      elLegendDesc.textContent = "Age total (estimated using 2024 population − registered).";
      elLegendBar.style.background = "linear-gradient(90deg, #dcfce7, #166534)";
      elLegMin.textContent = fmtInt(scale.min);
      elLegMax.textContent = fmtInt(scale.max);
    }
    return;
  }

  // fallback
  elLegendDesc.textContent = def ? def.label : "Legend";
  elLegendBar.style.background = "linear-gradient(90deg, #dcfce7, #166534)";
  elLegMin.textContent = "—";
  elLegMax.textContent = "—";
}

/* ------------------------------ Info panel -------------------------------- */
function refreshInfoPanel(featureOrNull){
  // If pinned: always show pinned feature; hover only updates tooltip.
  let feature = featureOrNull;
  if (selectedLayer?.feature) feature = selectedLayer.feature;

  if (!feature){
    elDName.textContent = "District";
    elDSub.textContent = "Hover or click a district.";
    elGrid.innerHTML = "";
    elBars.style.display = "none";
    elENote.style.display = "block";
    elENote.textContent = "Hover or click a district to see details.";
    return;
  }

  const d = dataForFeature(feature);
  const plate = d.plate;
  const provTr = plate ? provinceNameFromPlate(plate) : "Unknown";
  const distLabel = feature?.properties?.name || "—";

  elDName.textContent = distLabel;
  elDSub.innerHTML = `<span class="chip"><span class="sw" style="background:${plate? '#60a5fa':'#94a3b8'}"></span>${provTr}</span>
                      <span class="chip"><span class="sw" style="background:#34d399"></span>Plate ${plate ?? "—"}</span>
                      ${selectedLayer ? `<span class="chip"><span class="sw" style="background:#0f172a"></span>Pinned</span>` : ""}`;

  // Metrics
  const popY = d.pop ? d.pop[String(activeYear)] : null;
  const pop2024 = d.pop ? d.pop["2024"] : null;
  const py = prevYear(activeYear);
  const popPrev = (d.pop && py) ? d.pop[String(py)] : null;

  const popChange = (Number.isFinite(popY) && Number.isFinite(popPrev)) ? (popY - popPrev) : null;
  const popChangePct = (Number.isFinite(popPrev) && popPrev !== 0 && Number.isFinite(popY)) ? ((popY - popPrev)/popPrev) : null;

  const reg = d.elec?.registered ?? null;
  const cast = d.elec?.cast ?? null;
  const valid = d.elec?.valid ?? null;

  const turnout = (Number.isFinite(reg) && reg>0 && Number.isFinite(cast)) ? (cast/reg) : null;

  const u18 = (Number.isFinite(pop2024) && pop2024>0 && Number.isFinite(reg)) ? clamp(pop2024 - reg, 0, pop2024) : null;
  const u18pct = (Number.isFinite(u18) && Number.isFinite(pop2024) && pop2024>0) ? (u18/pop2024) : null;
  const p18 = (Number.isFinite(reg)) ? reg : null;
  const p18pct = (Number.isFinite(p18) && Number.isFinite(pop2024) && pop2024>0) ? (p18/pop2024) : null;

  const metrics = [
    { k:`Population (${activeYear})`, v: fmtInt(popY), s: py ? `vs ${py}: ${popChange===null?"—":(popChange>=0?"+":"") + fmtInt(popChange)}` : "No previous year" },
    { k:`Pop change %`, v: popChangePct===null ? "—" : ((popChangePct>=0?"+":"") + (popChangePct*100).toFixed(2).replace(".",",") + "%"), s: py ? `(${py}→${activeYear})` : "—" },

    { k:`Registered (18+)`, v: fmtInt(reg), s: "from election JSON" },
    { k:`Votes cast`, v: fmtInt(cast), s: "from election JSON" },
    { k:`Valid votes`, v: fmtInt(valid), s: "from election JSON" },
    { k:`Turnout`, v: turnout===null ? "—" : (turnout*100).toFixed(2).replace(".",",") + "%", s: "cast / registered" },

    { k:`0–18 total (est.)`, v: fmtInt(u18), s: "2024 pop − registered" },
    { k:`0–18 %`, v: u18pct===null ? "—" : (u18pct*100).toFixed(2).replace(".",",") + "%", s: "share of 2024 pop" },
    { k:`18+ total`, v: fmtInt(p18), s: "≈ registered" },
    { k:`18+ %`, v: p18pct===null ? "—" : (p18pct*100).toFixed(2).replace(".",",") + "%", s: "share of 2024 pop" },
  ];

  elGrid.innerHTML = metrics.map(m => `
    <div class="metric">
      <div class="k">${m.k}</div>
      <div class="v">${m.v}</div>
      <div class="s">${m.s}</div>
    </div>
  `).join("");

  // Election block
  const e = d.elec;
  if (!e || !e.votes || e.votes.size === 0 || !e.winner){
    elBars.style.display = "none";
    elENote.style.display = "block";
    elENote.textContent = "No election data for this district (missing province JSON or join mismatch).";
    return;
  }

  elENote.style.display = "none";
  elBars.style.display = "flex";

  const denom = Number.isFinite(e.denom) && e.denom>0 ? e.denom : (Number.isFinite(e.valid) && e.valid>0 ? e.valid : null);
  const sorted = [...e.votes.entries()].sort((a,b)=>b[1]-a[1]).slice(0,8);

  const winnerVotes = e.votes.get(e.winner) ?? null;
  const runnerVotes = e.runnerUp ? (e.votes.get(e.runnerUp) ?? null) : null;

  const wShare = (Number.isFinite(winnerVotes) && Number.isFinite(denom) && denom>0) ? (winnerVotes/denom) : null;
  const rShare = (Number.isFinite(runnerVotes) && Number.isFinite(denom) && denom>0) ? (runnerVotes/denom) : null;
  const margin = (Number.isFinite(wShare) && Number.isFinite(rShare)) ? (wShare - rShare) : null;

  // header note in election section (compact)
  const winnerLabel = cleanLabel(e.winner);
  const runnerLabel = e.runnerUp ? cleanLabel(e.runnerUp) : null;
  const marginTxt = (margin===null) ? "—" : (margin*100).toFixed(2).replace(".",",") + "%";
  const wShareTxt = (wShare===null) ? "—" : (wShare*100).toFixed(2).replace(".",",") + "%";

  // Replace note area with winner summary
  elENote.style.display = "block";
  elENote.innerHTML = `
    <span class="chip"><span class="sw" style="background:${partyColor(winnerLabel)}"></span>${winnerLabel}</span>
    ${runnerLabel ? `<span class="chip"><span class="sw" style="background:${partyColor(runnerLabel)}"></span>${runnerLabel}</span>` : ""}
    <span class="chip"><span class="sw" style="background:#0ea5e9"></span>Winner: ${wShareTxt}</span>
    <span class="chip"><span class="sw" style="background:#94a3b8"></span>Margin: ${marginTxt}</span>
  `;

  elBars.innerHTML = sorted.map(([p, v]) => {
    const pct = (Number.isFinite(denom) && denom>0) ? (v/denom) : null;
    const width = pct ? (pct*100) : 0;
    const col = partyColor(p);
    const pctTxt = pct ? (pct*100).toFixed(2).replace(".",",") + "%" : "—";
    return `
      <div class="bar-row">
        <div class="pname" title="${cleanLabel(p)}">
          <span class="swatch" style="background:${col}; box-shadow: 0 0 0 3px ${mix(col,"#ffffff",0.78)};"></span>
          ${cleanLabel(p)}
        </div>
        <div class="track"><div class="fill" style="width:${width.toFixed(2)}%; background:${col};"></div></div>
        <div class="val">${pctTxt} • ${fmtInt(v)}</div>
      </div>
    `;
  }).join("");
}
</script>
</body>
</html>
